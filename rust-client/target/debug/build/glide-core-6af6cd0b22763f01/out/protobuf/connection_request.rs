// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 3.20.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protobuf/connection_request.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:connection_request.NodeAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeAddress {
    // message fields
    // @@protoc_insertion_point(field:connection_request.NodeAddress.host)
    pub host: ::protobuf::Chars,
    // @@protoc_insertion_point(field:connection_request.NodeAddress.port)
    pub port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.NodeAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &NodeAddress| { &m.host },
            |m: &mut NodeAddress| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &NodeAddress| { &m.port },
            |m: &mut NodeAddress| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeAddress>(
            "NodeAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeAddress {
    const NAME: &'static str = "NodeAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_tokio_chars()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeAddress {
        static instance: NodeAddress = NodeAddress {
            host: ::protobuf::Chars::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.AuthenticationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticationInfo {
    // message fields
    // @@protoc_insertion_point(field:connection_request.AuthenticationInfo.password)
    pub password: ::protobuf::Chars,
    // @@protoc_insertion_point(field:connection_request.AuthenticationInfo.username)
    pub username: ::protobuf::Chars,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.AuthenticationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticationInfo {
    fn default() -> &'a AuthenticationInfo {
        <AuthenticationInfo as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationInfo {
    pub fn new() -> AuthenticationInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &AuthenticationInfo| { &m.password },
            |m: &mut AuthenticationInfo| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &AuthenticationInfo| { &m.username },
            |m: &mut AuthenticationInfo| { &mut m.username },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticationInfo>(
            "AuthenticationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthenticationInfo {
    const NAME: &'static str = "AuthenticationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.password = is.read_tokio_chars()?;
                },
                18 => {
                    self.username = is.read_tokio_chars()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticationInfo {
        AuthenticationInfo::new()
    }

    fn clear(&mut self) {
        self.password.clear();
        self.username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticationInfo {
        static instance: AuthenticationInfo = AuthenticationInfo {
            password: ::protobuf::Chars::new(),
            username: ::protobuf::Chars::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthenticationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthenticationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthenticationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.PeriodicChecksManualInterval)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeriodicChecksManualInterval {
    // message fields
    // @@protoc_insertion_point(field:connection_request.PeriodicChecksManualInterval.duration_in_sec)
    pub duration_in_sec: u32,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.PeriodicChecksManualInterval.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeriodicChecksManualInterval {
    fn default() -> &'a PeriodicChecksManualInterval {
        <PeriodicChecksManualInterval as ::protobuf::Message>::default_instance()
    }
}

impl PeriodicChecksManualInterval {
    pub fn new() -> PeriodicChecksManualInterval {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration_in_sec",
            |m: &PeriodicChecksManualInterval| { &m.duration_in_sec },
            |m: &mut PeriodicChecksManualInterval| { &mut m.duration_in_sec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeriodicChecksManualInterval>(
            "PeriodicChecksManualInterval",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeriodicChecksManualInterval {
    const NAME: &'static str = "PeriodicChecksManualInterval";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration_in_sec = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.duration_in_sec != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.duration_in_sec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.duration_in_sec != 0 {
            os.write_uint32(1, self.duration_in_sec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeriodicChecksManualInterval {
        PeriodicChecksManualInterval::new()
    }

    fn clear(&mut self) {
        self.duration_in_sec = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeriodicChecksManualInterval {
        static instance: PeriodicChecksManualInterval = PeriodicChecksManualInterval {
            duration_in_sec: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeriodicChecksManualInterval {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeriodicChecksManualInterval").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeriodicChecksManualInterval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeriodicChecksManualInterval {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.PeriodicChecksDisabled)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeriodicChecksDisabled {
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.PeriodicChecksDisabled.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeriodicChecksDisabled {
    fn default() -> &'a PeriodicChecksDisabled {
        <PeriodicChecksDisabled as ::protobuf::Message>::default_instance()
    }
}

impl PeriodicChecksDisabled {
    pub fn new() -> PeriodicChecksDisabled {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeriodicChecksDisabled>(
            "PeriodicChecksDisabled",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeriodicChecksDisabled {
    const NAME: &'static str = "PeriodicChecksDisabled";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeriodicChecksDisabled {
        PeriodicChecksDisabled::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeriodicChecksDisabled {
        static instance: PeriodicChecksDisabled = PeriodicChecksDisabled {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeriodicChecksDisabled {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeriodicChecksDisabled").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeriodicChecksDisabled {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeriodicChecksDisabled {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.PubSubChannelsOrPatterns)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PubSubChannelsOrPatterns {
    // message fields
    // @@protoc_insertion_point(field:connection_request.PubSubChannelsOrPatterns.channels_or_patterns)
    pub channels_or_patterns: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.PubSubChannelsOrPatterns.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubSubChannelsOrPatterns {
    fn default() -> &'a PubSubChannelsOrPatterns {
        <PubSubChannelsOrPatterns as ::protobuf::Message>::default_instance()
    }
}

impl PubSubChannelsOrPatterns {
    pub fn new() -> PubSubChannelsOrPatterns {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels_or_patterns",
            |m: &PubSubChannelsOrPatterns| { &m.channels_or_patterns },
            |m: &mut PubSubChannelsOrPatterns| { &mut m.channels_or_patterns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubSubChannelsOrPatterns>(
            "PubSubChannelsOrPatterns",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubSubChannelsOrPatterns {
    const NAME: &'static str = "PubSubChannelsOrPatterns";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channels_or_patterns.push(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.channels_or_patterns {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.channels_or_patterns {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubSubChannelsOrPatterns {
        PubSubChannelsOrPatterns::new()
    }

    fn clear(&mut self) {
        self.channels_or_patterns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubSubChannelsOrPatterns {
        static instance: PubSubChannelsOrPatterns = PubSubChannelsOrPatterns {
            channels_or_patterns: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PubSubChannelsOrPatterns {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubSubChannelsOrPatterns").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubSubChannelsOrPatterns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubSubChannelsOrPatterns {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.PubSubSubscriptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PubSubSubscriptions {
    // message fields
    // @@protoc_insertion_point(field:connection_request.PubSubSubscriptions.channels_or_patterns_by_type)
    pub channels_or_patterns_by_type: ::std::collections::HashMap<u32, PubSubChannelsOrPatterns>,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.PubSubSubscriptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PubSubSubscriptions {
    fn default() -> &'a PubSubSubscriptions {
        <PubSubSubscriptions as ::protobuf::Message>::default_instance()
    }
}

impl PubSubSubscriptions {
    pub fn new() -> PubSubSubscriptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "channels_or_patterns_by_type",
            |m: &PubSubSubscriptions| { &m.channels_or_patterns_by_type },
            |m: &mut PubSubSubscriptions| { &mut m.channels_or_patterns_by_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PubSubSubscriptions>(
            "PubSubSubscriptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PubSubSubscriptions {
    const NAME: &'static str = "PubSubSubscriptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.channels_or_patterns_by_type.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.channels_or_patterns_by_type {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.channels_or_patterns_by_type {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PubSubSubscriptions {
        PubSubSubscriptions::new()
    }

    fn clear(&mut self) {
        self.channels_or_patterns_by_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PubSubSubscriptions {
        static instance: ::protobuf::rt::Lazy<PubSubSubscriptions> = ::protobuf::rt::Lazy::new();
        instance.get(PubSubSubscriptions::new)
    }
}

impl ::protobuf::MessageFull for PubSubSubscriptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PubSubSubscriptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PubSubSubscriptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubSubSubscriptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:connection_request.ConnectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectionRequest {
    // message fields
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.addresses)
    pub addresses: ::std::vec::Vec<NodeAddress>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.tls_mode)
    pub tls_mode: ::protobuf::EnumOrUnknown<TlsMode>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.cluster_mode_enabled)
    pub cluster_mode_enabled: bool,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.request_timeout)
    pub request_timeout: u32,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.read_from)
    pub read_from: ::protobuf::EnumOrUnknown<ReadFrom>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.connection_retry_strategy)
    pub connection_retry_strategy: ::protobuf::MessageField<ConnectionRetryStrategy>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.authentication_info)
    pub authentication_info: ::protobuf::MessageField<AuthenticationInfo>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.database_id)
    pub database_id: u32,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<ProtocolVersion>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.client_name)
    pub client_name: ::protobuf::Chars,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.pubsub_subscriptions)
    pub pubsub_subscriptions: ::protobuf::MessageField<PubSubSubscriptions>,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.inflight_requests_limit)
    pub inflight_requests_limit: u32,
    // @@protoc_insertion_point(field:connection_request.ConnectionRequest.client_az)
    pub client_az: ::protobuf::Chars,
    // message oneof groups
    pub periodic_checks: ::std::option::Option<connection_request::Periodic_checks>,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.ConnectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectionRequest {
    fn default() -> &'a ConnectionRequest {
        <ConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionRequest {
    pub fn new() -> ConnectionRequest {
        ::std::default::Default::default()
    }

    // .connection_request.PeriodicChecksManualInterval periodic_checks_manual_interval = 11;

    pub fn periodic_checks_manual_interval(&self) -> &PeriodicChecksManualInterval {
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(ref v)) => v,
            _ => <PeriodicChecksManualInterval as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_periodic_checks_manual_interval(&mut self) {
        self.periodic_checks = ::std::option::Option::None;
    }

    pub fn has_periodic_checks_manual_interval(&self) -> bool {
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_periodic_checks_manual_interval(&mut self, v: PeriodicChecksManualInterval) {
        self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(v))
    }

    // Mutable pointer to the field.
    pub fn mut_periodic_checks_manual_interval(&mut self) -> &mut PeriodicChecksManualInterval {
        if let ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(_)) = self.periodic_checks {
        } else {
            self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(PeriodicChecksManualInterval::new()));
        }
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_periodic_checks_manual_interval(&mut self) -> PeriodicChecksManualInterval {
        if self.has_periodic_checks_manual_interval() {
            match self.periodic_checks.take() {
                ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(v)) => v,
                _ => panic!(),
            }
        } else {
            PeriodicChecksManualInterval::new()
        }
    }

    // .connection_request.PeriodicChecksDisabled periodic_checks_disabled = 12;

    pub fn periodic_checks_disabled(&self) -> &PeriodicChecksDisabled {
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(ref v)) => v,
            _ => <PeriodicChecksDisabled as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_periodic_checks_disabled(&mut self) {
        self.periodic_checks = ::std::option::Option::None;
    }

    pub fn has_periodic_checks_disabled(&self) -> bool {
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_periodic_checks_disabled(&mut self, v: PeriodicChecksDisabled) {
        self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(v))
    }

    // Mutable pointer to the field.
    pub fn mut_periodic_checks_disabled(&mut self) -> &mut PeriodicChecksDisabled {
        if let ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(_)) = self.periodic_checks {
        } else {
            self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(PeriodicChecksDisabled::new()));
        }
        match self.periodic_checks {
            ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_periodic_checks_disabled(&mut self) -> PeriodicChecksDisabled {
        if self.has_periodic_checks_disabled() {
            match self.periodic_checks.take() {
                ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(v)) => v,
                _ => panic!(),
            }
        } else {
            PeriodicChecksDisabled::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &ConnectionRequest| { &m.addresses },
            |m: &mut ConnectionRequest| { &mut m.addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tls_mode",
            |m: &ConnectionRequest| { &m.tls_mode },
            |m: &mut ConnectionRequest| { &mut m.tls_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cluster_mode_enabled",
            |m: &ConnectionRequest| { &m.cluster_mode_enabled },
            |m: &mut ConnectionRequest| { &mut m.cluster_mode_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_timeout",
            |m: &ConnectionRequest| { &m.request_timeout },
            |m: &mut ConnectionRequest| { &mut m.request_timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "read_from",
            |m: &ConnectionRequest| { &m.read_from },
            |m: &mut ConnectionRequest| { &mut m.read_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectionRetryStrategy>(
            "connection_retry_strategy",
            |m: &ConnectionRequest| { &m.connection_retry_strategy },
            |m: &mut ConnectionRequest| { &mut m.connection_retry_strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AuthenticationInfo>(
            "authentication_info",
            |m: &ConnectionRequest| { &m.authentication_info },
            |m: &mut ConnectionRequest| { &mut m.authentication_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "database_id",
            |m: &ConnectionRequest| { &m.database_id },
            |m: &mut ConnectionRequest| { &mut m.database_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &ConnectionRequest| { &m.protocol },
            |m: &mut ConnectionRequest| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_name",
            |m: &ConnectionRequest| { &m.client_name },
            |m: &mut ConnectionRequest| { &mut m.client_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeriodicChecksManualInterval>(
            "periodic_checks_manual_interval",
            ConnectionRequest::has_periodic_checks_manual_interval,
            ConnectionRequest::periodic_checks_manual_interval,
            ConnectionRequest::mut_periodic_checks_manual_interval,
            ConnectionRequest::set_periodic_checks_manual_interval,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeriodicChecksDisabled>(
            "periodic_checks_disabled",
            ConnectionRequest::has_periodic_checks_disabled,
            ConnectionRequest::periodic_checks_disabled,
            ConnectionRequest::mut_periodic_checks_disabled,
            ConnectionRequest::set_periodic_checks_disabled,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PubSubSubscriptions>(
            "pubsub_subscriptions",
            |m: &ConnectionRequest| { &m.pubsub_subscriptions },
            |m: &mut ConnectionRequest| { &mut m.pubsub_subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inflight_requests_limit",
            |m: &ConnectionRequest| { &m.inflight_requests_limit },
            |m: &mut ConnectionRequest| { &mut m.inflight_requests_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_az",
            |m: &ConnectionRequest| { &m.client_az },
            |m: &mut ConnectionRequest| { &mut m.client_az },
        ));
        oneofs.push(connection_request::Periodic_checks::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectionRequest>(
            "ConnectionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectionRequest {
    const NAME: &'static str = "ConnectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                16 => {
                    self.tls_mode = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.cluster_mode_enabled = is.read_bool()?;
                },
                32 => {
                    self.request_timeout = is.read_uint32()?;
                },
                40 => {
                    self.read_from = is.read_enum_or_unknown()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_retry_strategy)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authentication_info)?;
                },
                64 => {
                    self.database_id = is.read_uint32()?;
                },
                72 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                82 => {
                    self.client_name = is.read_tokio_chars()?;
                },
                90 => {
                    self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksManualInterval(is.read_message()?));
                },
                98 => {
                    self.periodic_checks = ::std::option::Option::Some(connection_request::Periodic_checks::PeriodicChecksDisabled(is.read_message()?));
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pubsub_subscriptions)?;
                },
                112 => {
                    self.inflight_requests_limit = is.read_uint32()?;
                },
                122 => {
                    self.client_az = is.read_tokio_chars()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.tls_mode != ::protobuf::EnumOrUnknown::new(TlsMode::NoTls) {
            my_size += ::protobuf::rt::int32_size(2, self.tls_mode.value());
        }
        if self.cluster_mode_enabled != false {
            my_size += 1 + 1;
        }
        if self.request_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.request_timeout);
        }
        if self.read_from != ::protobuf::EnumOrUnknown::new(ReadFrom::Primary) {
            my_size += ::protobuf::rt::int32_size(5, self.read_from.value());
        }
        if let Some(v) = self.connection_retry_strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.authentication_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.database_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.database_id);
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ProtocolVersion::RESP3) {
            my_size += ::protobuf::rt::int32_size(9, self.protocol.value());
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.client_name);
        }
        if let Some(v) = self.pubsub_subscriptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.inflight_requests_limit != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.inflight_requests_limit);
        }
        if !self.client_az.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.client_az);
        }
        if let ::std::option::Option::Some(ref v) = self.periodic_checks {
            match v {
                &connection_request::Periodic_checks::PeriodicChecksManualInterval(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection_request::Periodic_checks::PeriodicChecksDisabled(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.tls_mode != ::protobuf::EnumOrUnknown::new(TlsMode::NoTls) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.tls_mode))?;
        }
        if self.cluster_mode_enabled != false {
            os.write_bool(3, self.cluster_mode_enabled)?;
        }
        if self.request_timeout != 0 {
            os.write_uint32(4, self.request_timeout)?;
        }
        if self.read_from != ::protobuf::EnumOrUnknown::new(ReadFrom::Primary) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.read_from))?;
        }
        if let Some(v) = self.connection_retry_strategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.authentication_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.database_id != 0 {
            os.write_uint32(8, self.database_id)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ProtocolVersion::RESP3) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        if !self.client_name.is_empty() {
            os.write_string(10, &self.client_name)?;
        }
        if let Some(v) = self.pubsub_subscriptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.inflight_requests_limit != 0 {
            os.write_uint32(14, self.inflight_requests_limit)?;
        }
        if !self.client_az.is_empty() {
            os.write_string(15, &self.client_az)?;
        }
        if let ::std::option::Option::Some(ref v) = self.periodic_checks {
            match v {
                &connection_request::Periodic_checks::PeriodicChecksManualInterval(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &connection_request::Periodic_checks::PeriodicChecksDisabled(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectionRequest {
        ConnectionRequest::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.tls_mode = ::protobuf::EnumOrUnknown::new(TlsMode::NoTls);
        self.cluster_mode_enabled = false;
        self.request_timeout = 0;
        self.read_from = ::protobuf::EnumOrUnknown::new(ReadFrom::Primary);
        self.connection_retry_strategy.clear();
        self.authentication_info.clear();
        self.database_id = 0;
        self.protocol = ::protobuf::EnumOrUnknown::new(ProtocolVersion::RESP3);
        self.client_name.clear();
        self.periodic_checks = ::std::option::Option::None;
        self.periodic_checks = ::std::option::Option::None;
        self.pubsub_subscriptions.clear();
        self.inflight_requests_limit = 0;
        self.client_az.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectionRequest {
        static instance: ConnectionRequest = ConnectionRequest {
            addresses: ::std::vec::Vec::new(),
            tls_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            cluster_mode_enabled: false,
            request_timeout: 0,
            read_from: ::protobuf::EnumOrUnknown::from_i32(0),
            connection_retry_strategy: ::protobuf::MessageField::none(),
            authentication_info: ::protobuf::MessageField::none(),
            database_id: 0,
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            client_name: ::protobuf::Chars::new(),
            pubsub_subscriptions: ::protobuf::MessageField::none(),
            inflight_requests_limit: 0,
            client_az: ::protobuf::Chars::new(),
            periodic_checks: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConnectionRequest`
pub mod connection_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:connection_request.ConnectionRequest.periodic_checks)
    pub enum Periodic_checks {
        // @@protoc_insertion_point(oneof_field:connection_request.ConnectionRequest.periodic_checks_manual_interval)
        PeriodicChecksManualInterval(super::PeriodicChecksManualInterval),
        // @@protoc_insertion_point(oneof_field:connection_request.ConnectionRequest.periodic_checks_disabled)
        PeriodicChecksDisabled(super::PeriodicChecksDisabled),
    }

    impl ::protobuf::Oneof for Periodic_checks {
    }

    impl ::protobuf::OneofFull for Periodic_checks {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ConnectionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("periodic_checks").unwrap()).clone()
        }
    }

    impl Periodic_checks {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Periodic_checks>("periodic_checks")
        }
    }
}

// @@protoc_insertion_point(message:connection_request.ConnectionRetryStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectionRetryStrategy {
    // message fields
    // @@protoc_insertion_point(field:connection_request.ConnectionRetryStrategy.number_of_retries)
    pub number_of_retries: u32,
    // @@protoc_insertion_point(field:connection_request.ConnectionRetryStrategy.factor)
    pub factor: u32,
    // @@protoc_insertion_point(field:connection_request.ConnectionRetryStrategy.exponent_base)
    pub exponent_base: u32,
    // special fields
    // @@protoc_insertion_point(special_field:connection_request.ConnectionRetryStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectionRetryStrategy {
    fn default() -> &'a ConnectionRetryStrategy {
        <ConnectionRetryStrategy as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionRetryStrategy {
    pub fn new() -> ConnectionRetryStrategy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number_of_retries",
            |m: &ConnectionRetryStrategy| { &m.number_of_retries },
            |m: &mut ConnectionRetryStrategy| { &mut m.number_of_retries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "factor",
            |m: &ConnectionRetryStrategy| { &m.factor },
            |m: &mut ConnectionRetryStrategy| { &mut m.factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exponent_base",
            |m: &ConnectionRetryStrategy| { &m.exponent_base },
            |m: &mut ConnectionRetryStrategy| { &mut m.exponent_base },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectionRetryStrategy>(
            "ConnectionRetryStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectionRetryStrategy {
    const NAME: &'static str = "ConnectionRetryStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.number_of_retries = is.read_uint32()?;
                },
                16 => {
                    self.factor = is.read_uint32()?;
                },
                24 => {
                    self.exponent_base = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.number_of_retries != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.number_of_retries);
        }
        if self.factor != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.factor);
        }
        if self.exponent_base != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.exponent_base);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.number_of_retries != 0 {
            os.write_uint32(1, self.number_of_retries)?;
        }
        if self.factor != 0 {
            os.write_uint32(2, self.factor)?;
        }
        if self.exponent_base != 0 {
            os.write_uint32(3, self.exponent_base)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectionRetryStrategy {
        ConnectionRetryStrategy::new()
    }

    fn clear(&mut self) {
        self.number_of_retries = 0;
        self.factor = 0;
        self.exponent_base = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectionRetryStrategy {
        static instance: ConnectionRetryStrategy = ConnectionRetryStrategy {
            number_of_retries: 0,
            factor: 0,
            exponent_base: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectionRetryStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectionRetryStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectionRetryStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRetryStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:connection_request.ReadFrom)
pub enum ReadFrom {
    // @@protoc_insertion_point(enum_value:connection_request.ReadFrom.Primary)
    Primary = 0,
    // @@protoc_insertion_point(enum_value:connection_request.ReadFrom.PreferReplica)
    PreferReplica = 1,
    // @@protoc_insertion_point(enum_value:connection_request.ReadFrom.LowestLatency)
    LowestLatency = 2,
    // @@protoc_insertion_point(enum_value:connection_request.ReadFrom.AZAffinity)
    AZAffinity = 3,
}

impl ::protobuf::Enum for ReadFrom {
    const NAME: &'static str = "ReadFrom";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReadFrom> {
        match value {
            0 => ::std::option::Option::Some(ReadFrom::Primary),
            1 => ::std::option::Option::Some(ReadFrom::PreferReplica),
            2 => ::std::option::Option::Some(ReadFrom::LowestLatency),
            3 => ::std::option::Option::Some(ReadFrom::AZAffinity),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReadFrom> {
        match str {
            "Primary" => ::std::option::Option::Some(ReadFrom::Primary),
            "PreferReplica" => ::std::option::Option::Some(ReadFrom::PreferReplica),
            "LowestLatency" => ::std::option::Option::Some(ReadFrom::LowestLatency),
            "AZAffinity" => ::std::option::Option::Some(ReadFrom::AZAffinity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReadFrom] = &[
        ReadFrom::Primary,
        ReadFrom::PreferReplica,
        ReadFrom::LowestLatency,
        ReadFrom::AZAffinity,
    ];
}

impl ::protobuf::EnumFull for ReadFrom {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReadFrom").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReadFrom {
    fn default() -> Self {
        ReadFrom::Primary
    }
}

impl ReadFrom {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReadFrom>("ReadFrom")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:connection_request.TlsMode)
pub enum TlsMode {
    // @@protoc_insertion_point(enum_value:connection_request.TlsMode.NoTls)
    NoTls = 0,
    // @@protoc_insertion_point(enum_value:connection_request.TlsMode.SecureTls)
    SecureTls = 1,
    // @@protoc_insertion_point(enum_value:connection_request.TlsMode.InsecureTls)
    InsecureTls = 2,
}

impl ::protobuf::Enum for TlsMode {
    const NAME: &'static str = "TlsMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TlsMode> {
        match value {
            0 => ::std::option::Option::Some(TlsMode::NoTls),
            1 => ::std::option::Option::Some(TlsMode::SecureTls),
            2 => ::std::option::Option::Some(TlsMode::InsecureTls),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TlsMode> {
        match str {
            "NoTls" => ::std::option::Option::Some(TlsMode::NoTls),
            "SecureTls" => ::std::option::Option::Some(TlsMode::SecureTls),
            "InsecureTls" => ::std::option::Option::Some(TlsMode::InsecureTls),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TlsMode] = &[
        TlsMode::NoTls,
        TlsMode::SecureTls,
        TlsMode::InsecureTls,
    ];
}

impl ::protobuf::EnumFull for TlsMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TlsMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TlsMode {
    fn default() -> Self {
        TlsMode::NoTls
    }
}

impl TlsMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TlsMode>("TlsMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:connection_request.ProtocolVersion)
pub enum ProtocolVersion {
    // @@protoc_insertion_point(enum_value:connection_request.ProtocolVersion.RESP3)
    RESP3 = 0,
    // @@protoc_insertion_point(enum_value:connection_request.ProtocolVersion.RESP2)
    RESP2 = 1,
}

impl ::protobuf::Enum for ProtocolVersion {
    const NAME: &'static str = "ProtocolVersion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolVersion> {
        match value {
            0 => ::std::option::Option::Some(ProtocolVersion::RESP3),
            1 => ::std::option::Option::Some(ProtocolVersion::RESP2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtocolVersion> {
        match str {
            "RESP3" => ::std::option::Option::Some(ProtocolVersion::RESP3),
            "RESP2" => ::std::option::Option::Some(ProtocolVersion::RESP2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtocolVersion] = &[
        ProtocolVersion::RESP3,
        ProtocolVersion::RESP2,
    ];
}

impl ::protobuf::EnumFull for ProtocolVersion {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtocolVersion").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtocolVersion {
    fn default() -> Self {
        ProtocolVersion::RESP3
    }
}

impl ProtocolVersion {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtocolVersion>("ProtocolVersion")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:connection_request.PubSubChannelType)
pub enum PubSubChannelType {
    // @@protoc_insertion_point(enum_value:connection_request.PubSubChannelType.Exact)
    Exact = 0,
    // @@protoc_insertion_point(enum_value:connection_request.PubSubChannelType.Pattern)
    Pattern = 1,
    // @@protoc_insertion_point(enum_value:connection_request.PubSubChannelType.Sharded)
    Sharded = 2,
}

impl ::protobuf::Enum for PubSubChannelType {
    const NAME: &'static str = "PubSubChannelType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PubSubChannelType> {
        match value {
            0 => ::std::option::Option::Some(PubSubChannelType::Exact),
            1 => ::std::option::Option::Some(PubSubChannelType::Pattern),
            2 => ::std::option::Option::Some(PubSubChannelType::Sharded),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PubSubChannelType> {
        match str {
            "Exact" => ::std::option::Option::Some(PubSubChannelType::Exact),
            "Pattern" => ::std::option::Option::Some(PubSubChannelType::Pattern),
            "Sharded" => ::std::option::Option::Some(PubSubChannelType::Sharded),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PubSubChannelType] = &[
        PubSubChannelType::Exact,
        PubSubChannelType::Pattern,
        PubSubChannelType::Sharded,
    ];
}

impl ::protobuf::EnumFull for PubSubChannelType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PubSubChannelType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PubSubChannelType {
    fn default() -> Self {
        PubSubChannelType::Exact
    }
}

impl PubSubChannelType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PubSubChannelType>("PubSubChannelType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!protobuf/connection_request.proto\x12\x12connection_request\"5\n\x0bN\
    odeAddress\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04po\
    rt\x18\x02\x20\x01(\rR\x04port\"L\n\x12AuthenticationInfo\x12\x1a\n\x08p\
    assword\x18\x01\x20\x01(\tR\x08password\x12\x1a\n\x08username\x18\x02\
    \x20\x01(\tR\x08username\"F\n\x1cPeriodicChecksManualInterval\x12&\n\x0f\
    duration_in_sec\x18\x01\x20\x01(\rR\rdurationInSec\"\x18\n\x16PeriodicCh\
    ecksDisabled\"L\n\x18PubSubChannelsOrPatterns\x120\n\x14channels_or_patt\
    erns\x18\x01\x20\x03(\x0cR\x12channelsOrPatterns\"\x98\x02\n\x13PubSubSu\
    bscriptions\x12\x85\x01\n\x1cchannels_or_patterns_by_type\x18\x01\x20\
    \x03(\x0b2E.connection_request.PubSubSubscriptions.ChannelsOrPatternsByT\
    ypeEntryR\x18channelsOrPatternsByType\x1ay\n\x1dChannelsOrPatternsByType\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12B\n\x05value\x18\
    \x02\x20\x01(\x0b2,.connection_request.PubSubChannelsOrPatternsR\x05valu\
    e:\x028\x01\"\x8c\x08\n\x11ConnectionRequest\x12=\n\taddresses\x18\x01\
    \x20\x03(\x0b2\x1f.connection_request.NodeAddressR\taddresses\x126\n\x08\
    tls_mode\x18\x02\x20\x01(\x0e2\x1b.connection_request.TlsModeR\x07tlsMod\
    e\x120\n\x14cluster_mode_enabled\x18\x03\x20\x01(\x08R\x12clusterModeEna\
    bled\x12'\n\x0frequest_timeout\x18\x04\x20\x01(\rR\x0erequestTimeout\x12\
    9\n\tread_from\x18\x05\x20\x01(\x0e2\x1c.connection_request.ReadFromR\
    \x08readFrom\x12g\n\x19connection_retry_strategy\x18\x06\x20\x01(\x0b2+.\
    connection_request.ConnectionRetryStrategyR\x17connectionRetryStrategy\
    \x12W\n\x13authentication_info\x18\x07\x20\x01(\x0b2&.connection_request\
    .AuthenticationInfoR\x12authenticationInfo\x12\x1f\n\x0bdatabase_id\x18\
    \x08\x20\x01(\rR\ndatabaseId\x12?\n\x08protocol\x18\t\x20\x01(\x0e2#.con\
    nection_request.ProtocolVersionR\x08protocol\x12\x1f\n\x0bclient_name\
    \x18\n\x20\x01(\tR\nclientName\x12y\n\x1fperiodic_checks_manual_interval\
    \x18\x0b\x20\x01(\x0b20.connection_request.PeriodicChecksManualIntervalH\
    \0R\x1cperiodicChecksManualInterval\x12f\n\x18periodic_checks_disabled\
    \x18\x0c\x20\x01(\x0b2*.connection_request.PeriodicChecksDisabledH\0R\
    \x16periodicChecksDisabled\x12Z\n\x14pubsub_subscriptions\x18\r\x20\x01(\
    \x0b2'.connection_request.PubSubSubscriptionsR\x13pubsubSubscriptions\
    \x126\n\x17inflight_requests_limit\x18\x0e\x20\x01(\rR\x15inflightReques\
    tsLimit\x12\x1b\n\tclient_az\x18\x0f\x20\x01(\tR\x08clientAzB\x11\n\x0fp\
    eriodic_checks\"\x82\x01\n\x17ConnectionRetryStrategy\x12*\n\x11number_o\
    f_retries\x18\x01\x20\x01(\rR\x0fnumberOfRetries\x12\x16\n\x06factor\x18\
    \x02\x20\x01(\rR\x06factor\x12#\n\rexponent_base\x18\x03\x20\x01(\rR\x0c\
    exponentBase*M\n\x08ReadFrom\x12\x0b\n\x07Primary\x10\0\x12\x11\n\rPrefe\
    rReplica\x10\x01\x12\x11\n\rLowestLatency\x10\x02\x12\x0e\n\nAZAffinity\
    \x10\x03*4\n\x07TlsMode\x12\t\n\x05NoTls\x10\0\x12\r\n\tSecureTls\x10\
    \x01\x12\x0f\n\x0bInsecureTls\x10\x02*'\n\x0fProtocolVersion\x12\t\n\x05\
    RESP3\x10\0\x12\t\n\x05RESP2\x10\x01*8\n\x11PubSubChannelType\x12\t\n\
    \x05Exact\x10\0\x12\x0b\n\x07Pattern\x10\x01\x12\x0b\n\x07Sharded\x10\
    \x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(NodeAddress::generated_message_descriptor_data());
            messages.push(AuthenticationInfo::generated_message_descriptor_data());
            messages.push(PeriodicChecksManualInterval::generated_message_descriptor_data());
            messages.push(PeriodicChecksDisabled::generated_message_descriptor_data());
            messages.push(PubSubChannelsOrPatterns::generated_message_descriptor_data());
            messages.push(PubSubSubscriptions::generated_message_descriptor_data());
            messages.push(ConnectionRequest::generated_message_descriptor_data());
            messages.push(ConnectionRetryStrategy::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(ReadFrom::generated_enum_descriptor_data());
            enums.push(TlsMode::generated_enum_descriptor_data());
            enums.push(ProtocolVersion::generated_enum_descriptor_data());
            enums.push(PubSubChannelType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
