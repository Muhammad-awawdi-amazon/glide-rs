// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 3.20.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protobuf/command_request.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:command_request.SlotIdRoute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SlotIdRoute {
    // message fields
    // @@protoc_insertion_point(field:command_request.SlotIdRoute.slot_type)
    pub slot_type: ::protobuf::EnumOrUnknown<SlotTypes>,
    // @@protoc_insertion_point(field:command_request.SlotIdRoute.slot_id)
    pub slot_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.SlotIdRoute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SlotIdRoute {
    fn default() -> &'a SlotIdRoute {
        <SlotIdRoute as ::protobuf::Message>::default_instance()
    }
}

impl SlotIdRoute {
    pub fn new() -> SlotIdRoute {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_type",
            |m: &SlotIdRoute| { &m.slot_type },
            |m: &mut SlotIdRoute| { &mut m.slot_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_id",
            |m: &SlotIdRoute| { &m.slot_id },
            |m: &mut SlotIdRoute| { &mut m.slot_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SlotIdRoute>(
            "SlotIdRoute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SlotIdRoute {
    const NAME: &'static str = "SlotIdRoute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot_type = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.slot_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot_type != ::protobuf::EnumOrUnknown::new(SlotTypes::Primary) {
            my_size += ::protobuf::rt::int32_size(1, self.slot_type.value());
        }
        if self.slot_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.slot_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot_type != ::protobuf::EnumOrUnknown::new(SlotTypes::Primary) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.slot_type))?;
        }
        if self.slot_id != 0 {
            os.write_int32(2, self.slot_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SlotIdRoute {
        SlotIdRoute::new()
    }

    fn clear(&mut self) {
        self.slot_type = ::protobuf::EnumOrUnknown::new(SlotTypes::Primary);
        self.slot_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SlotIdRoute {
        static instance: SlotIdRoute = SlotIdRoute {
            slot_type: ::protobuf::EnumOrUnknown::from_i32(0),
            slot_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SlotIdRoute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SlotIdRoute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SlotIdRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlotIdRoute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.SlotKeyRoute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SlotKeyRoute {
    // message fields
    // @@protoc_insertion_point(field:command_request.SlotKeyRoute.slot_type)
    pub slot_type: ::protobuf::EnumOrUnknown<SlotTypes>,
    // @@protoc_insertion_point(field:command_request.SlotKeyRoute.slot_key)
    pub slot_key: ::protobuf::Chars,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.SlotKeyRoute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SlotKeyRoute {
    fn default() -> &'a SlotKeyRoute {
        <SlotKeyRoute as ::protobuf::Message>::default_instance()
    }
}

impl SlotKeyRoute {
    pub fn new() -> SlotKeyRoute {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_type",
            |m: &SlotKeyRoute| { &m.slot_type },
            |m: &mut SlotKeyRoute| { &mut m.slot_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slot_key",
            |m: &SlotKeyRoute| { &m.slot_key },
            |m: &mut SlotKeyRoute| { &mut m.slot_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SlotKeyRoute>(
            "SlotKeyRoute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SlotKeyRoute {
    const NAME: &'static str = "SlotKeyRoute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.slot_key = is.read_tokio_chars()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.slot_type != ::protobuf::EnumOrUnknown::new(SlotTypes::Primary) {
            my_size += ::protobuf::rt::int32_size(1, self.slot_type.value());
        }
        if !self.slot_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slot_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.slot_type != ::protobuf::EnumOrUnknown::new(SlotTypes::Primary) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.slot_type))?;
        }
        if !self.slot_key.is_empty() {
            os.write_string(2, &self.slot_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SlotKeyRoute {
        SlotKeyRoute::new()
    }

    fn clear(&mut self) {
        self.slot_type = ::protobuf::EnumOrUnknown::new(SlotTypes::Primary);
        self.slot_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SlotKeyRoute {
        static instance: SlotKeyRoute = SlotKeyRoute {
            slot_type: ::protobuf::EnumOrUnknown::from_i32(0),
            slot_key: ::protobuf::Chars::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SlotKeyRoute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SlotKeyRoute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SlotKeyRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlotKeyRoute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.ByAddressRoute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ByAddressRoute {
    // message fields
    // @@protoc_insertion_point(field:command_request.ByAddressRoute.host)
    pub host: ::protobuf::Chars,
    // @@protoc_insertion_point(field:command_request.ByAddressRoute.port)
    pub port: i32,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.ByAddressRoute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ByAddressRoute {
    fn default() -> &'a ByAddressRoute {
        <ByAddressRoute as ::protobuf::Message>::default_instance()
    }
}

impl ByAddressRoute {
    pub fn new() -> ByAddressRoute {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &ByAddressRoute| { &m.host },
            |m: &mut ByAddressRoute| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ByAddressRoute| { &m.port },
            |m: &mut ByAddressRoute| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ByAddressRoute>(
            "ByAddressRoute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ByAddressRoute {
    const NAME: &'static str = "ByAddressRoute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_tokio_chars()?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ByAddressRoute {
        ByAddressRoute::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ByAddressRoute {
        static instance: ByAddressRoute = ByAddressRoute {
            host: ::protobuf::Chars::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ByAddressRoute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ByAddressRoute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ByAddressRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ByAddressRoute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.Routes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Routes {
    // message oneof groups
    pub value: ::std::option::Option<routes::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.Routes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Routes {
    fn default() -> &'a Routes {
        <Routes as ::protobuf::Message>::default_instance()
    }
}

impl Routes {
    pub fn new() -> Routes {
        ::std::default::Default::default()
    }

    // .command_request.SimpleRoutes simple_routes = 1;

    pub fn simple_routes(&self) -> SimpleRoutes {
        match self.value {
            ::std::option::Option::Some(routes::Value::SimpleRoutes(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => SimpleRoutes::AllNodes,
        }
    }

    pub fn clear_simple_routes(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_simple_routes(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(routes::Value::SimpleRoutes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple_routes(&mut self, v: SimpleRoutes) {
        self.value = ::std::option::Option::Some(routes::Value::SimpleRoutes(::protobuf::EnumOrUnknown::new(v)))
    }

    // .command_request.SlotKeyRoute slot_key_route = 2;

    pub fn slot_key_route(&self) -> &SlotKeyRoute {
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotKeyRoute(ref v)) => v,
            _ => <SlotKeyRoute as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_slot_key_route(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_slot_key_route(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotKeyRoute(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_slot_key_route(&mut self, v: SlotKeyRoute) {
        self.value = ::std::option::Option::Some(routes::Value::SlotKeyRoute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_slot_key_route(&mut self) -> &mut SlotKeyRoute {
        if let ::std::option::Option::Some(routes::Value::SlotKeyRoute(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(routes::Value::SlotKeyRoute(SlotKeyRoute::new()));
        }
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotKeyRoute(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_slot_key_route(&mut self) -> SlotKeyRoute {
        if self.has_slot_key_route() {
            match self.value.take() {
                ::std::option::Option::Some(routes::Value::SlotKeyRoute(v)) => v,
                _ => panic!(),
            }
        } else {
            SlotKeyRoute::new()
        }
    }

    // .command_request.SlotIdRoute slot_id_route = 3;

    pub fn slot_id_route(&self) -> &SlotIdRoute {
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotIdRoute(ref v)) => v,
            _ => <SlotIdRoute as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_slot_id_route(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_slot_id_route(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotIdRoute(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_slot_id_route(&mut self, v: SlotIdRoute) {
        self.value = ::std::option::Option::Some(routes::Value::SlotIdRoute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_slot_id_route(&mut self) -> &mut SlotIdRoute {
        if let ::std::option::Option::Some(routes::Value::SlotIdRoute(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(routes::Value::SlotIdRoute(SlotIdRoute::new()));
        }
        match self.value {
            ::std::option::Option::Some(routes::Value::SlotIdRoute(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_slot_id_route(&mut self) -> SlotIdRoute {
        if self.has_slot_id_route() {
            match self.value.take() {
                ::std::option::Option::Some(routes::Value::SlotIdRoute(v)) => v,
                _ => panic!(),
            }
        } else {
            SlotIdRoute::new()
        }
    }

    // .command_request.ByAddressRoute by_address_route = 4;

    pub fn by_address_route(&self) -> &ByAddressRoute {
        match self.value {
            ::std::option::Option::Some(routes::Value::ByAddressRoute(ref v)) => v,
            _ => <ByAddressRoute as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_by_address_route(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_by_address_route(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(routes::Value::ByAddressRoute(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_by_address_route(&mut self, v: ByAddressRoute) {
        self.value = ::std::option::Option::Some(routes::Value::ByAddressRoute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_by_address_route(&mut self) -> &mut ByAddressRoute {
        if let ::std::option::Option::Some(routes::Value::ByAddressRoute(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(routes::Value::ByAddressRoute(ByAddressRoute::new()));
        }
        match self.value {
            ::std::option::Option::Some(routes::Value::ByAddressRoute(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_by_address_route(&mut self) -> ByAddressRoute {
        if self.has_by_address_route() {
            match self.value.take() {
                ::std::option::Option::Some(routes::Value::ByAddressRoute(v)) => v,
                _ => panic!(),
            }
        } else {
            ByAddressRoute::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "simple_routes",
            |message: &Routes| match &message.value {
                ::std::option::Option::Some(routes::Value::SimpleRoutes(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut Routes, e: ::protobuf::EnumOrUnknown<SimpleRoutes>| {
                message.value = ::std::option::Option::Some(routes::Value::SimpleRoutes(e));
            },
            SimpleRoutes::AllNodes,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SlotKeyRoute>(
            "slot_key_route",
            Routes::has_slot_key_route,
            Routes::slot_key_route,
            Routes::mut_slot_key_route,
            Routes::set_slot_key_route,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SlotIdRoute>(
            "slot_id_route",
            Routes::has_slot_id_route,
            Routes::slot_id_route,
            Routes::mut_slot_id_route,
            Routes::set_slot_id_route,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ByAddressRoute>(
            "by_address_route",
            Routes::has_by_address_route,
            Routes::by_address_route,
            Routes::mut_by_address_route,
            Routes::set_by_address_route,
        ));
        oneofs.push(routes::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Routes>(
            "Routes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Routes {
    const NAME: &'static str = "Routes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(routes::Value::SimpleRoutes(is.read_enum_or_unknown()?));
                },
                18 => {
                    self.value = ::std::option::Option::Some(routes::Value::SlotKeyRoute(is.read_message()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(routes::Value::SlotIdRoute(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(routes::Value::ByAddressRoute(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &routes::Value::SimpleRoutes(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
                &routes::Value::SlotKeyRoute(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &routes::Value::SlotIdRoute(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &routes::Value::ByAddressRoute(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &routes::Value::SimpleRoutes(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &routes::Value::SlotKeyRoute(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &routes::Value::SlotIdRoute(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &routes::Value::ByAddressRoute(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Routes {
        Routes::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Routes {
        static instance: Routes = Routes {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Routes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Routes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Routes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Routes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Routes`
pub mod routes {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:command_request.Routes.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:command_request.Routes.simple_routes)
        SimpleRoutes(::protobuf::EnumOrUnknown<super::SimpleRoutes>),
        // @@protoc_insertion_point(oneof_field:command_request.Routes.slot_key_route)
        SlotKeyRoute(super::SlotKeyRoute),
        // @@protoc_insertion_point(oneof_field:command_request.Routes.slot_id_route)
        SlotIdRoute(super::SlotIdRoute),
        // @@protoc_insertion_point(oneof_field:command_request.Routes.by_address_route)
        ByAddressRoute(super::ByAddressRoute),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Routes as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

// @@protoc_insertion_point(message:command_request.Command)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Command {
    // message fields
    // @@protoc_insertion_point(field:command_request.Command.request_type)
    pub request_type: ::protobuf::EnumOrUnknown<RequestType>,
    // message oneof groups
    pub args: ::std::option::Option<command::Args>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.Command.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Command {
    fn default() -> &'a Command {
        <Command as ::protobuf::Message>::default_instance()
    }
}

impl Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    // .command_request.Command.ArgsArray args_array = 2;

    pub fn args_array(&self) -> &command::ArgsArray {
        match self.args {
            ::std::option::Option::Some(command::Args::ArgsArray(ref v)) => v,
            _ => <command::ArgsArray as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_args_array(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args_array(&self) -> bool {
        match self.args {
            ::std::option::Option::Some(command::Args::ArgsArray(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_args_array(&mut self, v: command::ArgsArray) {
        self.args = ::std::option::Option::Some(command::Args::ArgsArray(v))
    }

    // Mutable pointer to the field.
    pub fn mut_args_array(&mut self) -> &mut command::ArgsArray {
        if let ::std::option::Option::Some(command::Args::ArgsArray(_)) = self.args {
        } else {
            self.args = ::std::option::Option::Some(command::Args::ArgsArray(command::ArgsArray::new()));
        }
        match self.args {
            ::std::option::Option::Some(command::Args::ArgsArray(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_args_array(&mut self) -> command::ArgsArray {
        if self.has_args_array() {
            match self.args.take() {
                ::std::option::Option::Some(command::Args::ArgsArray(v)) => v,
                _ => panic!(),
            }
        } else {
            command::ArgsArray::new()
        }
    }

    // uint64 args_vec_pointer = 3;

    pub fn args_vec_pointer(&self) -> u64 {
        match self.args {
            ::std::option::Option::Some(command::Args::ArgsVecPointer(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_args_vec_pointer(&mut self) {
        self.args = ::std::option::Option::None;
    }

    pub fn has_args_vec_pointer(&self) -> bool {
        match self.args {
            ::std::option::Option::Some(command::Args::ArgsVecPointer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_args_vec_pointer(&mut self, v: u64) {
        self.args = ::std::option::Option::Some(command::Args::ArgsVecPointer(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type",
            |m: &Command| { &m.request_type },
            |m: &mut Command| { &mut m.request_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, command::ArgsArray>(
            "args_array",
            Command::has_args_array,
            Command::args_array,
            Command::mut_args_array,
            Command::set_args_array,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "args_vec_pointer",
            Command::has_args_vec_pointer,
            Command::args_vec_pointer,
            Command::set_args_vec_pointer,
        ));
        oneofs.push(command::Args::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Command>(
            "Command",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Command {
    const NAME: &'static str = "Command";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.args = ::std::option::Option::Some(command::Args::ArgsArray(is.read_message()?));
                },
                24 => {
                    self.args = ::std::option::Option::Some(command::Args::ArgsVecPointer(is.read_uint64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.request_type != ::protobuf::EnumOrUnknown::new(RequestType::InvalidRequest) {
            my_size += ::protobuf::rt::int32_size(1, self.request_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.args {
            match v {
                &command::Args::ArgsArray(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command::Args::ArgsVecPointer(v) => {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.request_type != ::protobuf::EnumOrUnknown::new(RequestType::InvalidRequest) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.request_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.args {
            match v {
                &command::Args::ArgsArray(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &command::Args::ArgsVecPointer(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Command {
        Command::new()
    }

    fn clear(&mut self) {
        self.request_type = ::protobuf::EnumOrUnknown::new(RequestType::InvalidRequest);
        self.args = ::std::option::Option::None;
        self.args = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Command {
        static instance: Command = Command {
            request_type: ::protobuf::EnumOrUnknown::from_i32(0),
            args: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Command {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Command").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Command {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Command`
pub mod command {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:command_request.Command.args)
    pub enum Args {
        // @@protoc_insertion_point(oneof_field:command_request.Command.args_array)
        ArgsArray(ArgsArray),
        // @@protoc_insertion_point(oneof_field:command_request.Command.args_vec_pointer)
        ArgsVecPointer(u64),
    }

    impl ::protobuf::Oneof for Args {
    }

    impl ::protobuf::OneofFull for Args {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Command as ::protobuf::MessageFull>::descriptor().oneof_by_name("args").unwrap()).clone()
        }
    }

    impl Args {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Args>("args")
        }
    }
    // @@protoc_insertion_point(message:command_request.Command.ArgsArray)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ArgsArray {
        // message fields
        // @@protoc_insertion_point(field:command_request.Command.ArgsArray.args)
        pub args: ::std::vec::Vec<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:command_request.Command.ArgsArray.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ArgsArray {
        fn default() -> &'a ArgsArray {
            <ArgsArray as ::protobuf::Message>::default_instance()
        }
    }

    impl ArgsArray {
        pub fn new() -> ArgsArray {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "args",
                |m: &ArgsArray| { &m.args },
                |m: &mut ArgsArray| { &mut m.args },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArgsArray>(
                "Command.ArgsArray",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ArgsArray {
        const NAME: &'static str = "ArgsArray";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.args.push(is.read_tokio_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.args {
                my_size += ::protobuf::rt::bytes_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.args {
                os.write_bytes(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ArgsArray {
            ArgsArray::new()
        }

        fn clear(&mut self) {
            self.args.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ArgsArray {
            static instance: ArgsArray = ArgsArray {
                args: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ArgsArray {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Command.ArgsArray").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ArgsArray {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ArgsArray {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:command_request.ScriptInvocationPointers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScriptInvocationPointers {
    // message fields
    // @@protoc_insertion_point(field:command_request.ScriptInvocationPointers.hash)
    pub hash: ::protobuf::Chars,
    // @@protoc_insertion_point(field:command_request.ScriptInvocationPointers.keys_pointer)
    pub keys_pointer: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:command_request.ScriptInvocationPointers.args_pointer)
    pub args_pointer: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.ScriptInvocationPointers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptInvocationPointers {
    fn default() -> &'a ScriptInvocationPointers {
        <ScriptInvocationPointers as ::protobuf::Message>::default_instance()
    }
}

impl ScriptInvocationPointers {
    pub fn new() -> ScriptInvocationPointers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &ScriptInvocationPointers| { &m.hash },
            |m: &mut ScriptInvocationPointers| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keys_pointer",
            |m: &ScriptInvocationPointers| { &m.keys_pointer },
            |m: &mut ScriptInvocationPointers| { &mut m.keys_pointer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "args_pointer",
            |m: &ScriptInvocationPointers| { &m.args_pointer },
            |m: &mut ScriptInvocationPointers| { &mut m.args_pointer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptInvocationPointers>(
            "ScriptInvocationPointers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptInvocationPointers {
    const NAME: &'static str = "ScriptInvocationPointers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_tokio_chars()?;
                },
                16 => {
                    self.keys_pointer = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.args_pointer = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        if let Some(v) = self.keys_pointer {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.args_pointer {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        if let Some(v) = self.keys_pointer {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.args_pointer {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptInvocationPointers {
        ScriptInvocationPointers::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.keys_pointer = ::std::option::Option::None;
        self.args_pointer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptInvocationPointers {
        static instance: ScriptInvocationPointers = ScriptInvocationPointers {
            hash: ::protobuf::Chars::new(),
            keys_pointer: ::std::option::Option::None,
            args_pointer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptInvocationPointers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptInvocationPointers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptInvocationPointers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptInvocationPointers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.ScriptInvocation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScriptInvocation {
    // message fields
    // @@protoc_insertion_point(field:command_request.ScriptInvocation.hash)
    pub hash: ::protobuf::Chars,
    // @@protoc_insertion_point(field:command_request.ScriptInvocation.keys)
    pub keys: ::std::vec::Vec<::bytes::Bytes>,
    // @@protoc_insertion_point(field:command_request.ScriptInvocation.args)
    pub args: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.ScriptInvocation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptInvocation {
    fn default() -> &'a ScriptInvocation {
        <ScriptInvocation as ::protobuf::Message>::default_instance()
    }
}

impl ScriptInvocation {
    pub fn new() -> ScriptInvocation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &ScriptInvocation| { &m.hash },
            |m: &mut ScriptInvocation| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &ScriptInvocation| { &m.keys },
            |m: &mut ScriptInvocation| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ScriptInvocation| { &m.args },
            |m: &mut ScriptInvocation| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptInvocation>(
            "ScriptInvocation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptInvocation {
    const NAME: &'static str = "ScriptInvocation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_tokio_chars()?;
                },
                18 => {
                    self.keys.push(is.read_tokio_bytes()?);
                },
                26 => {
                    self.args.push(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        for v in &self.keys {
            os.write_bytes(2, &v)?;
        };
        for v in &self.args {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptInvocation {
        ScriptInvocation::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.keys.clear();
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptInvocation {
        static instance: ScriptInvocation = ScriptInvocation {
            hash: ::protobuf::Chars::new(),
            keys: ::std::vec::Vec::new(),
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptInvocation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptInvocation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptInvocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptInvocation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.Transaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:command_request.Transaction.commands)
    pub commands: ::std::vec::Vec<Command>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "commands",
            |m: &Transaction| { &m.commands },
            |m: &mut Transaction| { &mut m.commands },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commands.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.commands {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.commands.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            commands: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.ClusterScan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterScan {
    // message fields
    // @@protoc_insertion_point(field:command_request.ClusterScan.cursor)
    pub cursor: ::protobuf::Chars,
    // @@protoc_insertion_point(field:command_request.ClusterScan.match_pattern)
    pub match_pattern: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:command_request.ClusterScan.count)
    pub count: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:command_request.ClusterScan.object_type)
    pub object_type: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.ClusterScan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterScan {
    fn default() -> &'a ClusterScan {
        <ClusterScan as ::protobuf::Message>::default_instance()
    }
}

impl ClusterScan {
    pub fn new() -> ClusterScan {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ClusterScan| { &m.cursor },
            |m: &mut ClusterScan| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_pattern",
            |m: &ClusterScan| { &m.match_pattern },
            |m: &mut ClusterScan| { &mut m.match_pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &ClusterScan| { &m.count },
            |m: &mut ClusterScan| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "object_type",
            |m: &ClusterScan| { &m.object_type },
            |m: &mut ClusterScan| { &mut m.object_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterScan>(
            "ClusterScan",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterScan {
    const NAME: &'static str = "ClusterScan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cursor = is.read_tokio_chars()?;
                },
                18 => {
                    self.match_pattern = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.object_type = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cursor);
        }
        if let Some(v) = self.match_pattern.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.object_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.cursor.is_empty() {
            os.write_string(1, &self.cursor)?;
        }
        if let Some(v) = self.match_pattern.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.object_type.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterScan {
        ClusterScan::new()
    }

    fn clear(&mut self) {
        self.cursor.clear();
        self.match_pattern = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.object_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterScan {
        static instance: ClusterScan = ClusterScan {
            cursor: ::protobuf::Chars::new(),
            match_pattern: ::std::option::Option::None,
            count: ::std::option::Option::None,
            object_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterScan {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterScan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterScan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterScan {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.UpdateConnectionPassword)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateConnectionPassword {
    // message fields
    // @@protoc_insertion_point(field:command_request.UpdateConnectionPassword.password)
    pub password: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:command_request.UpdateConnectionPassword.immediate_auth)
    pub immediate_auth: bool,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.UpdateConnectionPassword.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateConnectionPassword {
    fn default() -> &'a UpdateConnectionPassword {
        <UpdateConnectionPassword as ::protobuf::Message>::default_instance()
    }
}

impl UpdateConnectionPassword {
    pub fn new() -> UpdateConnectionPassword {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &UpdateConnectionPassword| { &m.password },
            |m: &mut UpdateConnectionPassword| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "immediate_auth",
            |m: &UpdateConnectionPassword| { &m.immediate_auth },
            |m: &mut UpdateConnectionPassword| { &mut m.immediate_auth },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateConnectionPassword>(
            "UpdateConnectionPassword",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateConnectionPassword {
    const NAME: &'static str = "UpdateConnectionPassword";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.password = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                16 => {
                    self.immediate_auth = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if self.immediate_auth != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.password.as_ref() {
            os.write_string(1, v)?;
        }
        if self.immediate_auth != false {
            os.write_bool(2, self.immediate_auth)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateConnectionPassword {
        UpdateConnectionPassword::new()
    }

    fn clear(&mut self) {
        self.password = ::std::option::Option::None;
        self.immediate_auth = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateConnectionPassword {
        static instance: UpdateConnectionPassword = UpdateConnectionPassword {
            password: ::std::option::Option::None,
            immediate_auth: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateConnectionPassword {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateConnectionPassword").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateConnectionPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConnectionPassword {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:command_request.CommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandRequest {
    // message fields
    // @@protoc_insertion_point(field:command_request.CommandRequest.callback_idx)
    pub callback_idx: u32,
    // @@protoc_insertion_point(field:command_request.CommandRequest.route)
    pub route: ::protobuf::MessageField<Routes>,
    // message oneof groups
    pub command: ::std::option::Option<command_request::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:command_request.CommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommandRequest {
    fn default() -> &'a CommandRequest {
        <CommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommandRequest {
    pub fn new() -> CommandRequest {
        ::std::default::Default::default()
    }

    // .command_request.Command single_command = 2;

    pub fn single_command(&self) -> &Command {
        match self.command {
            ::std::option::Option::Some(command_request::Command::SingleCommand(ref v)) => v,
            _ => <Command as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_single_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_single_command(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::SingleCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_command(&mut self, v: Command) {
        self.command = ::std::option::Option::Some(command_request::Command::SingleCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_command(&mut self) -> &mut Command {
        if let ::std::option::Option::Some(command_request::Command::SingleCommand(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::SingleCommand(Command::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::SingleCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_command(&mut self) -> Command {
        if self.has_single_command() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::SingleCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            Command::new()
        }
    }

    // .command_request.Transaction transaction = 3;

    pub fn transaction(&self) -> &Transaction {
        match self.command {
            ::std::option::Option::Some(command_request::Command::Transaction(ref v)) => v,
            _ => <Transaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transaction(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::Transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: Transaction) {
        self.command = ::std::option::Option::Some(command_request::Command::Transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut Transaction {
        if let ::std::option::Option::Some(command_request::Command::Transaction(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::Transaction(Transaction::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::Transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> Transaction {
        if self.has_transaction() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::Transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction::new()
        }
    }

    // .command_request.ScriptInvocation script_invocation = 4;

    pub fn script_invocation(&self) -> &ScriptInvocation {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocation(ref v)) => v,
            _ => <ScriptInvocation as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_invocation(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_script_invocation(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_invocation(&mut self, v: ScriptInvocation) {
        self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_invocation(&mut self) -> &mut ScriptInvocation {
        if let ::std::option::Option::Some(command_request::Command::ScriptInvocation(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocation(ScriptInvocation::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_invocation(&mut self) -> ScriptInvocation {
        if self.has_script_invocation() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::ScriptInvocation(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptInvocation::new()
        }
    }

    // .command_request.ScriptInvocationPointers script_invocation_pointers = 5;

    pub fn script_invocation_pointers(&self) -> &ScriptInvocationPointers {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(ref v)) => v,
            _ => <ScriptInvocationPointers as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_invocation_pointers(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_script_invocation_pointers(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_invocation_pointers(&mut self, v: ScriptInvocationPointers) {
        self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_invocation_pointers(&mut self) -> &mut ScriptInvocationPointers {
        if let ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(ScriptInvocationPointers::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_invocation_pointers(&mut self) -> ScriptInvocationPointers {
        if self.has_script_invocation_pointers() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptInvocationPointers::new()
        }
    }

    // .command_request.ClusterScan cluster_scan = 6;

    pub fn cluster_scan(&self) -> &ClusterScan {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ClusterScan(ref v)) => v,
            _ => <ClusterScan as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cluster_scan(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_cluster_scan(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::ClusterScan(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_scan(&mut self, v: ClusterScan) {
        self.command = ::std::option::Option::Some(command_request::Command::ClusterScan(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_scan(&mut self) -> &mut ClusterScan {
        if let ::std::option::Option::Some(command_request::Command::ClusterScan(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::ClusterScan(ClusterScan::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::ClusterScan(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_scan(&mut self) -> ClusterScan {
        if self.has_cluster_scan() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::ClusterScan(v)) => v,
                _ => panic!(),
            }
        } else {
            ClusterScan::new()
        }
    }

    // .command_request.UpdateConnectionPassword update_connection_password = 7;

    pub fn update_connection_password(&self) -> &UpdateConnectionPassword {
        match self.command {
            ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(ref v)) => v,
            _ => <UpdateConnectionPassword as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_update_connection_password(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_update_connection_password(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_connection_password(&mut self, v: UpdateConnectionPassword) {
        self.command = ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_connection_password(&mut self) -> &mut UpdateConnectionPassword {
        if let ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(UpdateConnectionPassword::new()));
        }
        match self.command {
            ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_connection_password(&mut self) -> UpdateConnectionPassword {
        if self.has_update_connection_password() {
            match self.command.take() {
                ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(v)) => v,
                _ => panic!(),
            }
        } else {
            UpdateConnectionPassword::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "callback_idx",
            |m: &CommandRequest| { &m.callback_idx },
            |m: &mut CommandRequest| { &mut m.callback_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Command>(
            "single_command",
            CommandRequest::has_single_command,
            CommandRequest::single_command,
            CommandRequest::mut_single_command,
            CommandRequest::set_single_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Transaction>(
            "transaction",
            CommandRequest::has_transaction,
            CommandRequest::transaction,
            CommandRequest::mut_transaction,
            CommandRequest::set_transaction,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptInvocation>(
            "script_invocation",
            CommandRequest::has_script_invocation,
            CommandRequest::script_invocation,
            CommandRequest::mut_script_invocation,
            CommandRequest::set_script_invocation,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptInvocationPointers>(
            "script_invocation_pointers",
            CommandRequest::has_script_invocation_pointers,
            CommandRequest::script_invocation_pointers,
            CommandRequest::mut_script_invocation_pointers,
            CommandRequest::set_script_invocation_pointers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClusterScan>(
            "cluster_scan",
            CommandRequest::has_cluster_scan,
            CommandRequest::cluster_scan,
            CommandRequest::mut_cluster_scan,
            CommandRequest::set_cluster_scan,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UpdateConnectionPassword>(
            "update_connection_password",
            CommandRequest::has_update_connection_password,
            CommandRequest::update_connection_password,
            CommandRequest::mut_update_connection_password,
            CommandRequest::set_update_connection_password,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Routes>(
            "route",
            |m: &CommandRequest| { &m.route },
            |m: &mut CommandRequest| { &mut m.route },
        ));
        oneofs.push(command_request::Command::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommandRequest>(
            "CommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommandRequest {
    const NAME: &'static str = "CommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.callback_idx = is.read_uint32()?;
                },
                18 => {
                    self.command = ::std::option::Option::Some(command_request::Command::SingleCommand(is.read_message()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(command_request::Command::Transaction(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocation(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(command_request::Command::ScriptInvocationPointers(is.read_message()?));
                },
                50 => {
                    self.command = ::std::option::Option::Some(command_request::Command::ClusterScan(is.read_message()?));
                },
                58 => {
                    self.command = ::std::option::Option::Some(command_request::Command::UpdateConnectionPassword(is.read_message()?));
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.route)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.callback_idx != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.callback_idx);
        }
        if let Some(v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &command_request::Command::SingleCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command_request::Command::Transaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command_request::Command::ScriptInvocation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command_request::Command::ScriptInvocationPointers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command_request::Command::ClusterScan(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &command_request::Command::UpdateConnectionPassword(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.callback_idx != 0 {
            os.write_uint32(1, self.callback_idx)?;
        }
        if let Some(v) = self.route.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &command_request::Command::SingleCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &command_request::Command::Transaction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &command_request::Command::ScriptInvocation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &command_request::Command::ScriptInvocationPointers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &command_request::Command::ClusterScan(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &command_request::Command::UpdateConnectionPassword(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommandRequest {
        CommandRequest::new()
    }

    fn clear(&mut self) {
        self.callback_idx = 0;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.route.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommandRequest {
        static instance: CommandRequest = CommandRequest {
            callback_idx: 0,
            route: ::protobuf::MessageField::none(),
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CommandRequest`
pub mod command_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:command_request.CommandRequest.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.single_command)
        SingleCommand(super::Command),
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.transaction)
        Transaction(super::Transaction),
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.script_invocation)
        ScriptInvocation(super::ScriptInvocation),
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.script_invocation_pointers)
        ScriptInvocationPointers(super::ScriptInvocationPointers),
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.cluster_scan)
        ClusterScan(super::ClusterScan),
        // @@protoc_insertion_point(oneof_field:command_request.CommandRequest.update_connection_password)
        UpdateConnectionPassword(super::UpdateConnectionPassword),
    }

    impl ::protobuf::Oneof for Command {
    }

    impl ::protobuf::OneofFull for Command {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CommandRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("command").unwrap()).clone()
        }
    }

    impl Command {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Command>("command")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:command_request.SimpleRoutes)
pub enum SimpleRoutes {
    // @@protoc_insertion_point(enum_value:command_request.SimpleRoutes.AllNodes)
    AllNodes = 0,
    // @@protoc_insertion_point(enum_value:command_request.SimpleRoutes.AllPrimaries)
    AllPrimaries = 1,
    // @@protoc_insertion_point(enum_value:command_request.SimpleRoutes.Random)
    Random = 2,
}

impl ::protobuf::Enum for SimpleRoutes {
    const NAME: &'static str = "SimpleRoutes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SimpleRoutes> {
        match value {
            0 => ::std::option::Option::Some(SimpleRoutes::AllNodes),
            1 => ::std::option::Option::Some(SimpleRoutes::AllPrimaries),
            2 => ::std::option::Option::Some(SimpleRoutes::Random),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SimpleRoutes> {
        match str {
            "AllNodes" => ::std::option::Option::Some(SimpleRoutes::AllNodes),
            "AllPrimaries" => ::std::option::Option::Some(SimpleRoutes::AllPrimaries),
            "Random" => ::std::option::Option::Some(SimpleRoutes::Random),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SimpleRoutes] = &[
        SimpleRoutes::AllNodes,
        SimpleRoutes::AllPrimaries,
        SimpleRoutes::Random,
    ];
}

impl ::protobuf::EnumFull for SimpleRoutes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SimpleRoutes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SimpleRoutes {
    fn default() -> Self {
        SimpleRoutes::AllNodes
    }
}

impl SimpleRoutes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SimpleRoutes>("SimpleRoutes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:command_request.SlotTypes)
pub enum SlotTypes {
    // @@protoc_insertion_point(enum_value:command_request.SlotTypes.Primary)
    Primary = 0,
    // @@protoc_insertion_point(enum_value:command_request.SlotTypes.Replica)
    Replica = 1,
}

impl ::protobuf::Enum for SlotTypes {
    const NAME: &'static str = "SlotTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SlotTypes> {
        match value {
            0 => ::std::option::Option::Some(SlotTypes::Primary),
            1 => ::std::option::Option::Some(SlotTypes::Replica),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SlotTypes> {
        match str {
            "Primary" => ::std::option::Option::Some(SlotTypes::Primary),
            "Replica" => ::std::option::Option::Some(SlotTypes::Replica),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SlotTypes] = &[
        SlotTypes::Primary,
        SlotTypes::Replica,
    ];
}

impl ::protobuf::EnumFull for SlotTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SlotTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SlotTypes {
    fn default() -> Self {
        SlotTypes::Primary
    }
}

impl SlotTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SlotTypes>("SlotTypes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:command_request.RequestType)
pub enum RequestType {
    // @@protoc_insertion_point(enum_value:command_request.RequestType.InvalidRequest)
    InvalidRequest = 0,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CustomCommand)
    CustomCommand = 1,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BitCount)
    BitCount = 101,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BitField)
    BitField = 102,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BitFieldReadOnly)
    BitFieldReadOnly = 103,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BitOp)
    BitOp = 104,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BitPos)
    BitPos = 105,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GetBit)
    GetBit = 106,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SetBit)
    SetBit = 107,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Asking)
    Asking = 201,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterAddSlots)
    ClusterAddSlots = 202,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterAddSlotsRange)
    ClusterAddSlotsRange = 203,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterBumpEpoch)
    ClusterBumpEpoch = 204,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterCountFailureReports)
    ClusterCountFailureReports = 205,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterCountKeysInSlot)
    ClusterCountKeysInSlot = 206,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterDelSlots)
    ClusterDelSlots = 207,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterDelSlotsRange)
    ClusterDelSlotsRange = 208,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterFailover)
    ClusterFailover = 209,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterFlushSlots)
    ClusterFlushSlots = 210,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterForget)
    ClusterForget = 211,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterGetKeysInSlot)
    ClusterGetKeysInSlot = 212,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterInfo)
    ClusterInfo = 213,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterKeySlot)
    ClusterKeySlot = 214,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterLinks)
    ClusterLinks = 215,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterMeet)
    ClusterMeet = 216,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterMyId)
    ClusterMyId = 217,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterMyShardId)
    ClusterMyShardId = 218,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterNodes)
    ClusterNodes = 219,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterReplicas)
    ClusterReplicas = 220,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterReplicate)
    ClusterReplicate = 221,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterReset)
    ClusterReset = 222,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterSaveConfig)
    ClusterSaveConfig = 223,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterSetConfigEpoch)
    ClusterSetConfigEpoch = 224,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterSetslot)
    ClusterSetslot = 225,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterShards)
    ClusterShards = 226,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterSlaves)
    ClusterSlaves = 227,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClusterSlots)
    ClusterSlots = 228,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ReadOnly)
    ReadOnly = 229,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ReadWrite)
    ReadWrite = 230,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Auth)
    Auth = 301,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientCaching)
    ClientCaching = 302,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientGetName)
    ClientGetName = 303,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientGetRedir)
    ClientGetRedir = 304,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientId)
    ClientId = 305,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientInfo)
    ClientInfo = 306,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientKillSimple)
    ClientKillSimple = 307,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientKill)
    ClientKill = 308,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientList)
    ClientList = 309,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientNoEvict)
    ClientNoEvict = 310,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientNoTouch)
    ClientNoTouch = 311,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientPause)
    ClientPause = 312,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientReply)
    ClientReply = 313,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientSetInfo)
    ClientSetInfo = 314,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientSetName)
    ClientSetName = 315,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientTracking)
    ClientTracking = 316,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientTrackingInfo)
    ClientTrackingInfo = 317,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientUnblock)
    ClientUnblock = 318,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ClientUnpause)
    ClientUnpause = 319,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Echo)
    Echo = 320,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Hello)
    Hello = 321,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Ping)
    Ping = 322,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Quit)
    Quit = 323,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Reset)
    Reset = 324,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Select)
    Select = 325,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Copy)
    Copy = 401,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Del)
    Del = 402,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Dump)
    Dump = 403,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Exists)
    Exists = 404,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Expire)
    Expire = 405,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ExpireAt)
    ExpireAt = 406,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ExpireTime)
    ExpireTime = 407,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Keys)
    Keys = 408,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Migrate)
    Migrate = 409,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Move)
    Move = 410,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ObjectEncoding)
    ObjectEncoding = 411,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ObjectFreq)
    ObjectFreq = 412,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ObjectIdleTime)
    ObjectIdleTime = 413,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ObjectRefCount)
    ObjectRefCount = 414,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Persist)
    Persist = 415,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PExpire)
    PExpire = 416,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PExpireAt)
    PExpireAt = 417,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PExpireTime)
    PExpireTime = 418,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PTTL)
    PTTL = 419,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RandomKey)
    RandomKey = 420,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Rename)
    Rename = 421,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RenameNX)
    RenameNX = 422,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Restore)
    Restore = 423,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Scan)
    Scan = 424,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Sort)
    Sort = 425,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SortReadOnly)
    SortReadOnly = 426,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Touch)
    Touch = 427,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.TTL)
    TTL = 428,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Type)
    Type = 429,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Unlink)
    Unlink = 430,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Wait)
    Wait = 431,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.WaitAof)
    WaitAof = 432,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoAdd)
    GeoAdd = 501,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoDist)
    GeoDist = 502,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoHash)
    GeoHash = 503,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoPos)
    GeoPos = 504,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoRadius)
    GeoRadius = 505,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoRadiusReadOnly)
    GeoRadiusReadOnly = 506,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoRadiusByMember)
    GeoRadiusByMember = 507,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoRadiusByMemberReadOnly)
    GeoRadiusByMemberReadOnly = 508,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoSearch)
    GeoSearch = 509,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GeoSearchStore)
    GeoSearchStore = 510,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HDel)
    HDel = 601,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HExists)
    HExists = 602,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HGet)
    HGet = 603,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HGetAll)
    HGetAll = 604,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HIncrBy)
    HIncrBy = 605,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HIncrByFloat)
    HIncrByFloat = 606,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HKeys)
    HKeys = 607,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HLen)
    HLen = 608,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HMGet)
    HMGet = 609,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HMSet)
    HMSet = 610,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HRandField)
    HRandField = 611,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HScan)
    HScan = 612,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HSet)
    HSet = 613,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HSetNX)
    HSetNX = 614,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HStrlen)
    HStrlen = 615,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.HVals)
    HVals = 616,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PfAdd)
    PfAdd = 701,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PfCount)
    PfCount = 702,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PfMerge)
    PfMerge = 703,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BLMove)
    BLMove = 801,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BLMPop)
    BLMPop = 802,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BLPop)
    BLPop = 803,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BRPop)
    BRPop = 804,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BRPopLPush)
    BRPopLPush = 805,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LIndex)
    LIndex = 806,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LInsert)
    LInsert = 807,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LLen)
    LLen = 808,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LMove)
    LMove = 809,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LMPop)
    LMPop = 810,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LPop)
    LPop = 811,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LPos)
    LPos = 812,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LPush)
    LPush = 813,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LPushX)
    LPushX = 814,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LRange)
    LRange = 815,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LRem)
    LRem = 816,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LSet)
    LSet = 817,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LTrim)
    LTrim = 818,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RPop)
    RPop = 819,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RPopLPush)
    RPopLPush = 820,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RPush)
    RPush = 821,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RPushX)
    RPushX = 822,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PSubscribe)
    PSubscribe = 901,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Publish)
    Publish = 902,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PubSubChannels)
    PubSubChannels = 903,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PubSubNumPat)
    PubSubNumPat = 904,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PubSubNumSub)
    PubSubNumSub = 905,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PubSubShardChannels)
    PubSubShardChannels = 906,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PubSubShardNumSub)
    PubSubShardNumSub = 907,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PUnsubscribe)
    PUnsubscribe = 908,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SPublish)
    SPublish = 909,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SSubscribe)
    SSubscribe = 910,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Subscribe)
    Subscribe = 911,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SUnsubscribe)
    SUnsubscribe = 912,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Unsubscribe)
    Unsubscribe = 913,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Eval)
    Eval = 1001,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.EvalReadOnly)
    EvalReadOnly = 1002,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.EvalSha)
    EvalSha = 1003,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.EvalShaReadOnly)
    EvalShaReadOnly = 1004,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FCall)
    FCall = 1005,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FCallReadOnly)
    FCallReadOnly = 1006,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionDelete)
    FunctionDelete = 1007,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionDump)
    FunctionDump = 1008,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionFlush)
    FunctionFlush = 1009,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionKill)
    FunctionKill = 1010,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionList)
    FunctionList = 1011,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionLoad)
    FunctionLoad = 1012,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionRestore)
    FunctionRestore = 1013,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FunctionStats)
    FunctionStats = 1014,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptDebug)
    ScriptDebug = 1015,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptExists)
    ScriptExists = 1016,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptFlush)
    ScriptFlush = 1017,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptKill)
    ScriptKill = 1018,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptLoad)
    ScriptLoad = 1019,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ScriptShow)
    ScriptShow = 1020,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclCat)
    AclCat = 1101,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclDelUser)
    AclDelUser = 1102,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclDryRun)
    AclDryRun = 1103,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclGenPass)
    AclGenPass = 1104,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclGetUser)
    AclGetUser = 1105,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclList)
    AclList = 1106,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclLoad)
    AclLoad = 1107,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclLog)
    AclLog = 1108,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclSave)
    AclSave = 1109,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclSetSser)
    AclSetSser = 1110,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclUsers)
    AclUsers = 1111,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.AclWhoami)
    AclWhoami = 1112,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BgRewriteAof)
    BgRewriteAof = 1113,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BgSave)
    BgSave = 1114,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Command_)
    Command_ = 1115,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandCount)
    CommandCount = 1116,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandDocs)
    CommandDocs = 1117,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandGetKeys)
    CommandGetKeys = 1118,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandGetKeysAndFlags)
    CommandGetKeysAndFlags = 1119,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandInfo)
    CommandInfo = 1120,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.CommandList)
    CommandList = 1121,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ConfigGet)
    ConfigGet = 1122,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ConfigResetStat)
    ConfigResetStat = 1123,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ConfigRewrite)
    ConfigRewrite = 1124,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ConfigSet)
    ConfigSet = 1125,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.DBSize)
    DBSize = 1126,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FailOver)
    FailOver = 1127,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FlushAll)
    FlushAll = 1128,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FlushDB)
    FlushDB = 1129,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Info)
    Info = 1130,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LastSave)
    LastSave = 1131,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyDoctor)
    LatencyDoctor = 1132,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyGraph)
    LatencyGraph = 1133,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyHistogram)
    LatencyHistogram = 1134,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyHistory)
    LatencyHistory = 1135,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyLatest)
    LatencyLatest = 1136,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LatencyReset)
    LatencyReset = 1137,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Lolwut)
    Lolwut = 1138,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MemoryDoctor)
    MemoryDoctor = 1139,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MemoryMallocStats)
    MemoryMallocStats = 1140,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MemoryPurge)
    MemoryPurge = 1141,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MemoryStats)
    MemoryStats = 1142,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MemoryUsage)
    MemoryUsage = 1143,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ModuleList)
    ModuleList = 1144,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ModuleLoad)
    ModuleLoad = 1145,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ModuleLoadEx)
    ModuleLoadEx = 1146,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ModuleUnload)
    ModuleUnload = 1147,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Monitor)
    Monitor = 1148,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PSync)
    PSync = 1149,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ReplConf)
    ReplConf = 1150,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ReplicaOf)
    ReplicaOf = 1151,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.RestoreAsking)
    RestoreAsking = 1152,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Role)
    Role = 1153,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Save)
    Save = 1154,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ShutDown)
    ShutDown = 1155,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SlaveOf)
    SlaveOf = 1156,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SlowLogGet)
    SlowLogGet = 1157,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SlowLogLen)
    SlowLogLen = 1158,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SlowLogReset)
    SlowLogReset = 1159,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SwapDb)
    SwapDb = 1160,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Sync)
    Sync = 1161,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Time)
    Time = 1162,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SAdd)
    SAdd = 1201,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SCard)
    SCard = 1202,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SDiff)
    SDiff = 1203,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SDiffStore)
    SDiffStore = 1204,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SInter)
    SInter = 1205,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SInterCard)
    SInterCard = 1206,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SInterStore)
    SInterStore = 1207,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SIsMember)
    SIsMember = 1208,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SMembers)
    SMembers = 1209,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SMIsMember)
    SMIsMember = 1210,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SMove)
    SMove = 1211,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SPop)
    SPop = 1212,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SRandMember)
    SRandMember = 1213,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SRem)
    SRem = 1214,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SScan)
    SScan = 1215,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SUnion)
    SUnion = 1216,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SUnionStore)
    SUnionStore = 1217,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BZMPop)
    BZMPop = 1301,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BZPopMax)
    BZPopMax = 1302,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.BZPopMin)
    BZPopMin = 1303,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZAdd)
    ZAdd = 1304,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZCard)
    ZCard = 1305,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZCount)
    ZCount = 1306,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZDiff)
    ZDiff = 1307,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZDiffStore)
    ZDiffStore = 1308,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZIncrBy)
    ZIncrBy = 1309,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZInter)
    ZInter = 1310,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZInterCard)
    ZInterCard = 1311,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZInterStore)
    ZInterStore = 1312,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZLexCount)
    ZLexCount = 1313,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZMPop)
    ZMPop = 1314,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZMScore)
    ZMScore = 1315,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZPopMax)
    ZPopMax = 1316,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZPopMin)
    ZPopMin = 1317,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRandMember)
    ZRandMember = 1318,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRange)
    ZRange = 1319,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRangeByLex)
    ZRangeByLex = 1320,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRangeByScore)
    ZRangeByScore = 1321,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRangeStore)
    ZRangeStore = 1322,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRank)
    ZRank = 1323,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRem)
    ZRem = 1324,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRemRangeByLex)
    ZRemRangeByLex = 1325,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRemRangeByRank)
    ZRemRangeByRank = 1326,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRemRangeByScore)
    ZRemRangeByScore = 1327,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRevRange)
    ZRevRange = 1328,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRevRangeByLex)
    ZRevRangeByLex = 1329,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRevRangeByScore)
    ZRevRangeByScore = 1330,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZRevRank)
    ZRevRank = 1331,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZScan)
    ZScan = 1332,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZScore)
    ZScore = 1333,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZUnion)
    ZUnion = 1334,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.ZUnionStore)
    ZUnionStore = 1335,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XAck)
    XAck = 1401,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XAdd)
    XAdd = 1402,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XAutoClaim)
    XAutoClaim = 1403,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XClaim)
    XClaim = 1404,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XDel)
    XDel = 1405,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XGroupCreate)
    XGroupCreate = 1406,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XGroupCreateConsumer)
    XGroupCreateConsumer = 1407,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XGroupDelConsumer)
    XGroupDelConsumer = 1408,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XGroupDestroy)
    XGroupDestroy = 1409,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XGroupSetId)
    XGroupSetId = 1410,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XInfoConsumers)
    XInfoConsumers = 1411,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XInfoGroups)
    XInfoGroups = 1412,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XInfoStream)
    XInfoStream = 1413,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XLen)
    XLen = 1414,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XPending)
    XPending = 1415,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XRange)
    XRange = 1416,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XRead)
    XRead = 1417,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XReadGroup)
    XReadGroup = 1418,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XRevRange)
    XRevRange = 1419,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XSetId)
    XSetId = 1420,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.XTrim)
    XTrim = 1421,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Append)
    Append = 1501,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Decr)
    Decr = 1502,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.DecrBy)
    DecrBy = 1503,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Get)
    Get = 1504,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GetDel)
    GetDel = 1505,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GetEx)
    GetEx = 1506,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GetRange)
    GetRange = 1507,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.GetSet)
    GetSet = 1508,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Incr)
    Incr = 1509,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.IncrBy)
    IncrBy = 1510,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.IncrByFloat)
    IncrByFloat = 1511,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.LCS)
    LCS = 1512,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MGet)
    MGet = 1513,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MSet)
    MSet = 1514,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.MSetNX)
    MSetNX = 1515,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.PSetEx)
    PSetEx = 1516,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Set)
    Set = 1517,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SetEx)
    SetEx = 1518,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SetNX)
    SetNX = 1519,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.SetRange)
    SetRange = 1520,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Strlen)
    Strlen = 1521,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Substr)
    Substr = 1522,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Discard)
    Discard = 1601,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Exec)
    Exec = 1602,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Multi)
    Multi = 1603,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.UnWatch)
    UnWatch = 1604,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.Watch)
    Watch = 1605,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrAppend)
    JsonArrAppend = 2001,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrIndex)
    JsonArrIndex = 2002,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrInsert)
    JsonArrInsert = 2003,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrLen)
    JsonArrLen = 2004,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrPop)
    JsonArrPop = 2005,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonArrTrim)
    JsonArrTrim = 2006,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonClear)
    JsonClear = 2007,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonDebug)
    JsonDebug = 2008,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonDel)
    JsonDel = 2009,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonForget)
    JsonForget = 2010,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonGet)
    JsonGet = 2011,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonMGet)
    JsonMGet = 2012,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonNumIncrBy)
    JsonNumIncrBy = 2013,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonNumMultBy)
    JsonNumMultBy = 2014,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonObjKeys)
    JsonObjKeys = 2015,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonObjLen)
    JsonObjLen = 2016,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonResp)
    JsonResp = 2017,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonSet)
    JsonSet = 2018,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonStrAppend)
    JsonStrAppend = 2019,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonStrLen)
    JsonStrLen = 2020,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonToggle)
    JsonToggle = 2021,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.JsonType)
    JsonType = 2022,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtList)
    FtList = 2101,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtAggregate)
    FtAggregate = 2102,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtAliasAdd)
    FtAliasAdd = 2103,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtAliasDel)
    FtAliasDel = 2104,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtAliasList)
    FtAliasList = 2105,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtAliasUpdate)
    FtAliasUpdate = 2106,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtCreate)
    FtCreate = 2107,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtDropIndex)
    FtDropIndex = 2108,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtExplain)
    FtExplain = 2109,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtExplainCli)
    FtExplainCli = 2110,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtInfo)
    FtInfo = 2111,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtProfile)
    FtProfile = 2112,
    // @@protoc_insertion_point(enum_value:command_request.RequestType.FtSearch)
    FtSearch = 2113,
}

impl ::protobuf::Enum for RequestType {
    const NAME: &'static str = "RequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestType> {
        match value {
            0 => ::std::option::Option::Some(RequestType::InvalidRequest),
            1 => ::std::option::Option::Some(RequestType::CustomCommand),
            101 => ::std::option::Option::Some(RequestType::BitCount),
            102 => ::std::option::Option::Some(RequestType::BitField),
            103 => ::std::option::Option::Some(RequestType::BitFieldReadOnly),
            104 => ::std::option::Option::Some(RequestType::BitOp),
            105 => ::std::option::Option::Some(RequestType::BitPos),
            106 => ::std::option::Option::Some(RequestType::GetBit),
            107 => ::std::option::Option::Some(RequestType::SetBit),
            201 => ::std::option::Option::Some(RequestType::Asking),
            202 => ::std::option::Option::Some(RequestType::ClusterAddSlots),
            203 => ::std::option::Option::Some(RequestType::ClusterAddSlotsRange),
            204 => ::std::option::Option::Some(RequestType::ClusterBumpEpoch),
            205 => ::std::option::Option::Some(RequestType::ClusterCountFailureReports),
            206 => ::std::option::Option::Some(RequestType::ClusterCountKeysInSlot),
            207 => ::std::option::Option::Some(RequestType::ClusterDelSlots),
            208 => ::std::option::Option::Some(RequestType::ClusterDelSlotsRange),
            209 => ::std::option::Option::Some(RequestType::ClusterFailover),
            210 => ::std::option::Option::Some(RequestType::ClusterFlushSlots),
            211 => ::std::option::Option::Some(RequestType::ClusterForget),
            212 => ::std::option::Option::Some(RequestType::ClusterGetKeysInSlot),
            213 => ::std::option::Option::Some(RequestType::ClusterInfo),
            214 => ::std::option::Option::Some(RequestType::ClusterKeySlot),
            215 => ::std::option::Option::Some(RequestType::ClusterLinks),
            216 => ::std::option::Option::Some(RequestType::ClusterMeet),
            217 => ::std::option::Option::Some(RequestType::ClusterMyId),
            218 => ::std::option::Option::Some(RequestType::ClusterMyShardId),
            219 => ::std::option::Option::Some(RequestType::ClusterNodes),
            220 => ::std::option::Option::Some(RequestType::ClusterReplicas),
            221 => ::std::option::Option::Some(RequestType::ClusterReplicate),
            222 => ::std::option::Option::Some(RequestType::ClusterReset),
            223 => ::std::option::Option::Some(RequestType::ClusterSaveConfig),
            224 => ::std::option::Option::Some(RequestType::ClusterSetConfigEpoch),
            225 => ::std::option::Option::Some(RequestType::ClusterSetslot),
            226 => ::std::option::Option::Some(RequestType::ClusterShards),
            227 => ::std::option::Option::Some(RequestType::ClusterSlaves),
            228 => ::std::option::Option::Some(RequestType::ClusterSlots),
            229 => ::std::option::Option::Some(RequestType::ReadOnly),
            230 => ::std::option::Option::Some(RequestType::ReadWrite),
            301 => ::std::option::Option::Some(RequestType::Auth),
            302 => ::std::option::Option::Some(RequestType::ClientCaching),
            303 => ::std::option::Option::Some(RequestType::ClientGetName),
            304 => ::std::option::Option::Some(RequestType::ClientGetRedir),
            305 => ::std::option::Option::Some(RequestType::ClientId),
            306 => ::std::option::Option::Some(RequestType::ClientInfo),
            307 => ::std::option::Option::Some(RequestType::ClientKillSimple),
            308 => ::std::option::Option::Some(RequestType::ClientKill),
            309 => ::std::option::Option::Some(RequestType::ClientList),
            310 => ::std::option::Option::Some(RequestType::ClientNoEvict),
            311 => ::std::option::Option::Some(RequestType::ClientNoTouch),
            312 => ::std::option::Option::Some(RequestType::ClientPause),
            313 => ::std::option::Option::Some(RequestType::ClientReply),
            314 => ::std::option::Option::Some(RequestType::ClientSetInfo),
            315 => ::std::option::Option::Some(RequestType::ClientSetName),
            316 => ::std::option::Option::Some(RequestType::ClientTracking),
            317 => ::std::option::Option::Some(RequestType::ClientTrackingInfo),
            318 => ::std::option::Option::Some(RequestType::ClientUnblock),
            319 => ::std::option::Option::Some(RequestType::ClientUnpause),
            320 => ::std::option::Option::Some(RequestType::Echo),
            321 => ::std::option::Option::Some(RequestType::Hello),
            322 => ::std::option::Option::Some(RequestType::Ping),
            323 => ::std::option::Option::Some(RequestType::Quit),
            324 => ::std::option::Option::Some(RequestType::Reset),
            325 => ::std::option::Option::Some(RequestType::Select),
            401 => ::std::option::Option::Some(RequestType::Copy),
            402 => ::std::option::Option::Some(RequestType::Del),
            403 => ::std::option::Option::Some(RequestType::Dump),
            404 => ::std::option::Option::Some(RequestType::Exists),
            405 => ::std::option::Option::Some(RequestType::Expire),
            406 => ::std::option::Option::Some(RequestType::ExpireAt),
            407 => ::std::option::Option::Some(RequestType::ExpireTime),
            408 => ::std::option::Option::Some(RequestType::Keys),
            409 => ::std::option::Option::Some(RequestType::Migrate),
            410 => ::std::option::Option::Some(RequestType::Move),
            411 => ::std::option::Option::Some(RequestType::ObjectEncoding),
            412 => ::std::option::Option::Some(RequestType::ObjectFreq),
            413 => ::std::option::Option::Some(RequestType::ObjectIdleTime),
            414 => ::std::option::Option::Some(RequestType::ObjectRefCount),
            415 => ::std::option::Option::Some(RequestType::Persist),
            416 => ::std::option::Option::Some(RequestType::PExpire),
            417 => ::std::option::Option::Some(RequestType::PExpireAt),
            418 => ::std::option::Option::Some(RequestType::PExpireTime),
            419 => ::std::option::Option::Some(RequestType::PTTL),
            420 => ::std::option::Option::Some(RequestType::RandomKey),
            421 => ::std::option::Option::Some(RequestType::Rename),
            422 => ::std::option::Option::Some(RequestType::RenameNX),
            423 => ::std::option::Option::Some(RequestType::Restore),
            424 => ::std::option::Option::Some(RequestType::Scan),
            425 => ::std::option::Option::Some(RequestType::Sort),
            426 => ::std::option::Option::Some(RequestType::SortReadOnly),
            427 => ::std::option::Option::Some(RequestType::Touch),
            428 => ::std::option::Option::Some(RequestType::TTL),
            429 => ::std::option::Option::Some(RequestType::Type),
            430 => ::std::option::Option::Some(RequestType::Unlink),
            431 => ::std::option::Option::Some(RequestType::Wait),
            432 => ::std::option::Option::Some(RequestType::WaitAof),
            501 => ::std::option::Option::Some(RequestType::GeoAdd),
            502 => ::std::option::Option::Some(RequestType::GeoDist),
            503 => ::std::option::Option::Some(RequestType::GeoHash),
            504 => ::std::option::Option::Some(RequestType::GeoPos),
            505 => ::std::option::Option::Some(RequestType::GeoRadius),
            506 => ::std::option::Option::Some(RequestType::GeoRadiusReadOnly),
            507 => ::std::option::Option::Some(RequestType::GeoRadiusByMember),
            508 => ::std::option::Option::Some(RequestType::GeoRadiusByMemberReadOnly),
            509 => ::std::option::Option::Some(RequestType::GeoSearch),
            510 => ::std::option::Option::Some(RequestType::GeoSearchStore),
            601 => ::std::option::Option::Some(RequestType::HDel),
            602 => ::std::option::Option::Some(RequestType::HExists),
            603 => ::std::option::Option::Some(RequestType::HGet),
            604 => ::std::option::Option::Some(RequestType::HGetAll),
            605 => ::std::option::Option::Some(RequestType::HIncrBy),
            606 => ::std::option::Option::Some(RequestType::HIncrByFloat),
            607 => ::std::option::Option::Some(RequestType::HKeys),
            608 => ::std::option::Option::Some(RequestType::HLen),
            609 => ::std::option::Option::Some(RequestType::HMGet),
            610 => ::std::option::Option::Some(RequestType::HMSet),
            611 => ::std::option::Option::Some(RequestType::HRandField),
            612 => ::std::option::Option::Some(RequestType::HScan),
            613 => ::std::option::Option::Some(RequestType::HSet),
            614 => ::std::option::Option::Some(RequestType::HSetNX),
            615 => ::std::option::Option::Some(RequestType::HStrlen),
            616 => ::std::option::Option::Some(RequestType::HVals),
            701 => ::std::option::Option::Some(RequestType::PfAdd),
            702 => ::std::option::Option::Some(RequestType::PfCount),
            703 => ::std::option::Option::Some(RequestType::PfMerge),
            801 => ::std::option::Option::Some(RequestType::BLMove),
            802 => ::std::option::Option::Some(RequestType::BLMPop),
            803 => ::std::option::Option::Some(RequestType::BLPop),
            804 => ::std::option::Option::Some(RequestType::BRPop),
            805 => ::std::option::Option::Some(RequestType::BRPopLPush),
            806 => ::std::option::Option::Some(RequestType::LIndex),
            807 => ::std::option::Option::Some(RequestType::LInsert),
            808 => ::std::option::Option::Some(RequestType::LLen),
            809 => ::std::option::Option::Some(RequestType::LMove),
            810 => ::std::option::Option::Some(RequestType::LMPop),
            811 => ::std::option::Option::Some(RequestType::LPop),
            812 => ::std::option::Option::Some(RequestType::LPos),
            813 => ::std::option::Option::Some(RequestType::LPush),
            814 => ::std::option::Option::Some(RequestType::LPushX),
            815 => ::std::option::Option::Some(RequestType::LRange),
            816 => ::std::option::Option::Some(RequestType::LRem),
            817 => ::std::option::Option::Some(RequestType::LSet),
            818 => ::std::option::Option::Some(RequestType::LTrim),
            819 => ::std::option::Option::Some(RequestType::RPop),
            820 => ::std::option::Option::Some(RequestType::RPopLPush),
            821 => ::std::option::Option::Some(RequestType::RPush),
            822 => ::std::option::Option::Some(RequestType::RPushX),
            901 => ::std::option::Option::Some(RequestType::PSubscribe),
            902 => ::std::option::Option::Some(RequestType::Publish),
            903 => ::std::option::Option::Some(RequestType::PubSubChannels),
            904 => ::std::option::Option::Some(RequestType::PubSubNumPat),
            905 => ::std::option::Option::Some(RequestType::PubSubNumSub),
            906 => ::std::option::Option::Some(RequestType::PubSubShardChannels),
            907 => ::std::option::Option::Some(RequestType::PubSubShardNumSub),
            908 => ::std::option::Option::Some(RequestType::PUnsubscribe),
            909 => ::std::option::Option::Some(RequestType::SPublish),
            910 => ::std::option::Option::Some(RequestType::SSubscribe),
            911 => ::std::option::Option::Some(RequestType::Subscribe),
            912 => ::std::option::Option::Some(RequestType::SUnsubscribe),
            913 => ::std::option::Option::Some(RequestType::Unsubscribe),
            1001 => ::std::option::Option::Some(RequestType::Eval),
            1002 => ::std::option::Option::Some(RequestType::EvalReadOnly),
            1003 => ::std::option::Option::Some(RequestType::EvalSha),
            1004 => ::std::option::Option::Some(RequestType::EvalShaReadOnly),
            1005 => ::std::option::Option::Some(RequestType::FCall),
            1006 => ::std::option::Option::Some(RequestType::FCallReadOnly),
            1007 => ::std::option::Option::Some(RequestType::FunctionDelete),
            1008 => ::std::option::Option::Some(RequestType::FunctionDump),
            1009 => ::std::option::Option::Some(RequestType::FunctionFlush),
            1010 => ::std::option::Option::Some(RequestType::FunctionKill),
            1011 => ::std::option::Option::Some(RequestType::FunctionList),
            1012 => ::std::option::Option::Some(RequestType::FunctionLoad),
            1013 => ::std::option::Option::Some(RequestType::FunctionRestore),
            1014 => ::std::option::Option::Some(RequestType::FunctionStats),
            1015 => ::std::option::Option::Some(RequestType::ScriptDebug),
            1016 => ::std::option::Option::Some(RequestType::ScriptExists),
            1017 => ::std::option::Option::Some(RequestType::ScriptFlush),
            1018 => ::std::option::Option::Some(RequestType::ScriptKill),
            1019 => ::std::option::Option::Some(RequestType::ScriptLoad),
            1020 => ::std::option::Option::Some(RequestType::ScriptShow),
            1101 => ::std::option::Option::Some(RequestType::AclCat),
            1102 => ::std::option::Option::Some(RequestType::AclDelUser),
            1103 => ::std::option::Option::Some(RequestType::AclDryRun),
            1104 => ::std::option::Option::Some(RequestType::AclGenPass),
            1105 => ::std::option::Option::Some(RequestType::AclGetUser),
            1106 => ::std::option::Option::Some(RequestType::AclList),
            1107 => ::std::option::Option::Some(RequestType::AclLoad),
            1108 => ::std::option::Option::Some(RequestType::AclLog),
            1109 => ::std::option::Option::Some(RequestType::AclSave),
            1110 => ::std::option::Option::Some(RequestType::AclSetSser),
            1111 => ::std::option::Option::Some(RequestType::AclUsers),
            1112 => ::std::option::Option::Some(RequestType::AclWhoami),
            1113 => ::std::option::Option::Some(RequestType::BgRewriteAof),
            1114 => ::std::option::Option::Some(RequestType::BgSave),
            1115 => ::std::option::Option::Some(RequestType::Command_),
            1116 => ::std::option::Option::Some(RequestType::CommandCount),
            1117 => ::std::option::Option::Some(RequestType::CommandDocs),
            1118 => ::std::option::Option::Some(RequestType::CommandGetKeys),
            1119 => ::std::option::Option::Some(RequestType::CommandGetKeysAndFlags),
            1120 => ::std::option::Option::Some(RequestType::CommandInfo),
            1121 => ::std::option::Option::Some(RequestType::CommandList),
            1122 => ::std::option::Option::Some(RequestType::ConfigGet),
            1123 => ::std::option::Option::Some(RequestType::ConfigResetStat),
            1124 => ::std::option::Option::Some(RequestType::ConfigRewrite),
            1125 => ::std::option::Option::Some(RequestType::ConfigSet),
            1126 => ::std::option::Option::Some(RequestType::DBSize),
            1127 => ::std::option::Option::Some(RequestType::FailOver),
            1128 => ::std::option::Option::Some(RequestType::FlushAll),
            1129 => ::std::option::Option::Some(RequestType::FlushDB),
            1130 => ::std::option::Option::Some(RequestType::Info),
            1131 => ::std::option::Option::Some(RequestType::LastSave),
            1132 => ::std::option::Option::Some(RequestType::LatencyDoctor),
            1133 => ::std::option::Option::Some(RequestType::LatencyGraph),
            1134 => ::std::option::Option::Some(RequestType::LatencyHistogram),
            1135 => ::std::option::Option::Some(RequestType::LatencyHistory),
            1136 => ::std::option::Option::Some(RequestType::LatencyLatest),
            1137 => ::std::option::Option::Some(RequestType::LatencyReset),
            1138 => ::std::option::Option::Some(RequestType::Lolwut),
            1139 => ::std::option::Option::Some(RequestType::MemoryDoctor),
            1140 => ::std::option::Option::Some(RequestType::MemoryMallocStats),
            1141 => ::std::option::Option::Some(RequestType::MemoryPurge),
            1142 => ::std::option::Option::Some(RequestType::MemoryStats),
            1143 => ::std::option::Option::Some(RequestType::MemoryUsage),
            1144 => ::std::option::Option::Some(RequestType::ModuleList),
            1145 => ::std::option::Option::Some(RequestType::ModuleLoad),
            1146 => ::std::option::Option::Some(RequestType::ModuleLoadEx),
            1147 => ::std::option::Option::Some(RequestType::ModuleUnload),
            1148 => ::std::option::Option::Some(RequestType::Monitor),
            1149 => ::std::option::Option::Some(RequestType::PSync),
            1150 => ::std::option::Option::Some(RequestType::ReplConf),
            1151 => ::std::option::Option::Some(RequestType::ReplicaOf),
            1152 => ::std::option::Option::Some(RequestType::RestoreAsking),
            1153 => ::std::option::Option::Some(RequestType::Role),
            1154 => ::std::option::Option::Some(RequestType::Save),
            1155 => ::std::option::Option::Some(RequestType::ShutDown),
            1156 => ::std::option::Option::Some(RequestType::SlaveOf),
            1157 => ::std::option::Option::Some(RequestType::SlowLogGet),
            1158 => ::std::option::Option::Some(RequestType::SlowLogLen),
            1159 => ::std::option::Option::Some(RequestType::SlowLogReset),
            1160 => ::std::option::Option::Some(RequestType::SwapDb),
            1161 => ::std::option::Option::Some(RequestType::Sync),
            1162 => ::std::option::Option::Some(RequestType::Time),
            1201 => ::std::option::Option::Some(RequestType::SAdd),
            1202 => ::std::option::Option::Some(RequestType::SCard),
            1203 => ::std::option::Option::Some(RequestType::SDiff),
            1204 => ::std::option::Option::Some(RequestType::SDiffStore),
            1205 => ::std::option::Option::Some(RequestType::SInter),
            1206 => ::std::option::Option::Some(RequestType::SInterCard),
            1207 => ::std::option::Option::Some(RequestType::SInterStore),
            1208 => ::std::option::Option::Some(RequestType::SIsMember),
            1209 => ::std::option::Option::Some(RequestType::SMembers),
            1210 => ::std::option::Option::Some(RequestType::SMIsMember),
            1211 => ::std::option::Option::Some(RequestType::SMove),
            1212 => ::std::option::Option::Some(RequestType::SPop),
            1213 => ::std::option::Option::Some(RequestType::SRandMember),
            1214 => ::std::option::Option::Some(RequestType::SRem),
            1215 => ::std::option::Option::Some(RequestType::SScan),
            1216 => ::std::option::Option::Some(RequestType::SUnion),
            1217 => ::std::option::Option::Some(RequestType::SUnionStore),
            1301 => ::std::option::Option::Some(RequestType::BZMPop),
            1302 => ::std::option::Option::Some(RequestType::BZPopMax),
            1303 => ::std::option::Option::Some(RequestType::BZPopMin),
            1304 => ::std::option::Option::Some(RequestType::ZAdd),
            1305 => ::std::option::Option::Some(RequestType::ZCard),
            1306 => ::std::option::Option::Some(RequestType::ZCount),
            1307 => ::std::option::Option::Some(RequestType::ZDiff),
            1308 => ::std::option::Option::Some(RequestType::ZDiffStore),
            1309 => ::std::option::Option::Some(RequestType::ZIncrBy),
            1310 => ::std::option::Option::Some(RequestType::ZInter),
            1311 => ::std::option::Option::Some(RequestType::ZInterCard),
            1312 => ::std::option::Option::Some(RequestType::ZInterStore),
            1313 => ::std::option::Option::Some(RequestType::ZLexCount),
            1314 => ::std::option::Option::Some(RequestType::ZMPop),
            1315 => ::std::option::Option::Some(RequestType::ZMScore),
            1316 => ::std::option::Option::Some(RequestType::ZPopMax),
            1317 => ::std::option::Option::Some(RequestType::ZPopMin),
            1318 => ::std::option::Option::Some(RequestType::ZRandMember),
            1319 => ::std::option::Option::Some(RequestType::ZRange),
            1320 => ::std::option::Option::Some(RequestType::ZRangeByLex),
            1321 => ::std::option::Option::Some(RequestType::ZRangeByScore),
            1322 => ::std::option::Option::Some(RequestType::ZRangeStore),
            1323 => ::std::option::Option::Some(RequestType::ZRank),
            1324 => ::std::option::Option::Some(RequestType::ZRem),
            1325 => ::std::option::Option::Some(RequestType::ZRemRangeByLex),
            1326 => ::std::option::Option::Some(RequestType::ZRemRangeByRank),
            1327 => ::std::option::Option::Some(RequestType::ZRemRangeByScore),
            1328 => ::std::option::Option::Some(RequestType::ZRevRange),
            1329 => ::std::option::Option::Some(RequestType::ZRevRangeByLex),
            1330 => ::std::option::Option::Some(RequestType::ZRevRangeByScore),
            1331 => ::std::option::Option::Some(RequestType::ZRevRank),
            1332 => ::std::option::Option::Some(RequestType::ZScan),
            1333 => ::std::option::Option::Some(RequestType::ZScore),
            1334 => ::std::option::Option::Some(RequestType::ZUnion),
            1335 => ::std::option::Option::Some(RequestType::ZUnionStore),
            1401 => ::std::option::Option::Some(RequestType::XAck),
            1402 => ::std::option::Option::Some(RequestType::XAdd),
            1403 => ::std::option::Option::Some(RequestType::XAutoClaim),
            1404 => ::std::option::Option::Some(RequestType::XClaim),
            1405 => ::std::option::Option::Some(RequestType::XDel),
            1406 => ::std::option::Option::Some(RequestType::XGroupCreate),
            1407 => ::std::option::Option::Some(RequestType::XGroupCreateConsumer),
            1408 => ::std::option::Option::Some(RequestType::XGroupDelConsumer),
            1409 => ::std::option::Option::Some(RequestType::XGroupDestroy),
            1410 => ::std::option::Option::Some(RequestType::XGroupSetId),
            1411 => ::std::option::Option::Some(RequestType::XInfoConsumers),
            1412 => ::std::option::Option::Some(RequestType::XInfoGroups),
            1413 => ::std::option::Option::Some(RequestType::XInfoStream),
            1414 => ::std::option::Option::Some(RequestType::XLen),
            1415 => ::std::option::Option::Some(RequestType::XPending),
            1416 => ::std::option::Option::Some(RequestType::XRange),
            1417 => ::std::option::Option::Some(RequestType::XRead),
            1418 => ::std::option::Option::Some(RequestType::XReadGroup),
            1419 => ::std::option::Option::Some(RequestType::XRevRange),
            1420 => ::std::option::Option::Some(RequestType::XSetId),
            1421 => ::std::option::Option::Some(RequestType::XTrim),
            1501 => ::std::option::Option::Some(RequestType::Append),
            1502 => ::std::option::Option::Some(RequestType::Decr),
            1503 => ::std::option::Option::Some(RequestType::DecrBy),
            1504 => ::std::option::Option::Some(RequestType::Get),
            1505 => ::std::option::Option::Some(RequestType::GetDel),
            1506 => ::std::option::Option::Some(RequestType::GetEx),
            1507 => ::std::option::Option::Some(RequestType::GetRange),
            1508 => ::std::option::Option::Some(RequestType::GetSet),
            1509 => ::std::option::Option::Some(RequestType::Incr),
            1510 => ::std::option::Option::Some(RequestType::IncrBy),
            1511 => ::std::option::Option::Some(RequestType::IncrByFloat),
            1512 => ::std::option::Option::Some(RequestType::LCS),
            1513 => ::std::option::Option::Some(RequestType::MGet),
            1514 => ::std::option::Option::Some(RequestType::MSet),
            1515 => ::std::option::Option::Some(RequestType::MSetNX),
            1516 => ::std::option::Option::Some(RequestType::PSetEx),
            1517 => ::std::option::Option::Some(RequestType::Set),
            1518 => ::std::option::Option::Some(RequestType::SetEx),
            1519 => ::std::option::Option::Some(RequestType::SetNX),
            1520 => ::std::option::Option::Some(RequestType::SetRange),
            1521 => ::std::option::Option::Some(RequestType::Strlen),
            1522 => ::std::option::Option::Some(RequestType::Substr),
            1601 => ::std::option::Option::Some(RequestType::Discard),
            1602 => ::std::option::Option::Some(RequestType::Exec),
            1603 => ::std::option::Option::Some(RequestType::Multi),
            1604 => ::std::option::Option::Some(RequestType::UnWatch),
            1605 => ::std::option::Option::Some(RequestType::Watch),
            2001 => ::std::option::Option::Some(RequestType::JsonArrAppend),
            2002 => ::std::option::Option::Some(RequestType::JsonArrIndex),
            2003 => ::std::option::Option::Some(RequestType::JsonArrInsert),
            2004 => ::std::option::Option::Some(RequestType::JsonArrLen),
            2005 => ::std::option::Option::Some(RequestType::JsonArrPop),
            2006 => ::std::option::Option::Some(RequestType::JsonArrTrim),
            2007 => ::std::option::Option::Some(RequestType::JsonClear),
            2008 => ::std::option::Option::Some(RequestType::JsonDebug),
            2009 => ::std::option::Option::Some(RequestType::JsonDel),
            2010 => ::std::option::Option::Some(RequestType::JsonForget),
            2011 => ::std::option::Option::Some(RequestType::JsonGet),
            2012 => ::std::option::Option::Some(RequestType::JsonMGet),
            2013 => ::std::option::Option::Some(RequestType::JsonNumIncrBy),
            2014 => ::std::option::Option::Some(RequestType::JsonNumMultBy),
            2015 => ::std::option::Option::Some(RequestType::JsonObjKeys),
            2016 => ::std::option::Option::Some(RequestType::JsonObjLen),
            2017 => ::std::option::Option::Some(RequestType::JsonResp),
            2018 => ::std::option::Option::Some(RequestType::JsonSet),
            2019 => ::std::option::Option::Some(RequestType::JsonStrAppend),
            2020 => ::std::option::Option::Some(RequestType::JsonStrLen),
            2021 => ::std::option::Option::Some(RequestType::JsonToggle),
            2022 => ::std::option::Option::Some(RequestType::JsonType),
            2101 => ::std::option::Option::Some(RequestType::FtList),
            2102 => ::std::option::Option::Some(RequestType::FtAggregate),
            2103 => ::std::option::Option::Some(RequestType::FtAliasAdd),
            2104 => ::std::option::Option::Some(RequestType::FtAliasDel),
            2105 => ::std::option::Option::Some(RequestType::FtAliasList),
            2106 => ::std::option::Option::Some(RequestType::FtAliasUpdate),
            2107 => ::std::option::Option::Some(RequestType::FtCreate),
            2108 => ::std::option::Option::Some(RequestType::FtDropIndex),
            2109 => ::std::option::Option::Some(RequestType::FtExplain),
            2110 => ::std::option::Option::Some(RequestType::FtExplainCli),
            2111 => ::std::option::Option::Some(RequestType::FtInfo),
            2112 => ::std::option::Option::Some(RequestType::FtProfile),
            2113 => ::std::option::Option::Some(RequestType::FtSearch),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RequestType> {
        match str {
            "InvalidRequest" => ::std::option::Option::Some(RequestType::InvalidRequest),
            "CustomCommand" => ::std::option::Option::Some(RequestType::CustomCommand),
            "BitCount" => ::std::option::Option::Some(RequestType::BitCount),
            "BitField" => ::std::option::Option::Some(RequestType::BitField),
            "BitFieldReadOnly" => ::std::option::Option::Some(RequestType::BitFieldReadOnly),
            "BitOp" => ::std::option::Option::Some(RequestType::BitOp),
            "BitPos" => ::std::option::Option::Some(RequestType::BitPos),
            "GetBit" => ::std::option::Option::Some(RequestType::GetBit),
            "SetBit" => ::std::option::Option::Some(RequestType::SetBit),
            "Asking" => ::std::option::Option::Some(RequestType::Asking),
            "ClusterAddSlots" => ::std::option::Option::Some(RequestType::ClusterAddSlots),
            "ClusterAddSlotsRange" => ::std::option::Option::Some(RequestType::ClusterAddSlotsRange),
            "ClusterBumpEpoch" => ::std::option::Option::Some(RequestType::ClusterBumpEpoch),
            "ClusterCountFailureReports" => ::std::option::Option::Some(RequestType::ClusterCountFailureReports),
            "ClusterCountKeysInSlot" => ::std::option::Option::Some(RequestType::ClusterCountKeysInSlot),
            "ClusterDelSlots" => ::std::option::Option::Some(RequestType::ClusterDelSlots),
            "ClusterDelSlotsRange" => ::std::option::Option::Some(RequestType::ClusterDelSlotsRange),
            "ClusterFailover" => ::std::option::Option::Some(RequestType::ClusterFailover),
            "ClusterFlushSlots" => ::std::option::Option::Some(RequestType::ClusterFlushSlots),
            "ClusterForget" => ::std::option::Option::Some(RequestType::ClusterForget),
            "ClusterGetKeysInSlot" => ::std::option::Option::Some(RequestType::ClusterGetKeysInSlot),
            "ClusterInfo" => ::std::option::Option::Some(RequestType::ClusterInfo),
            "ClusterKeySlot" => ::std::option::Option::Some(RequestType::ClusterKeySlot),
            "ClusterLinks" => ::std::option::Option::Some(RequestType::ClusterLinks),
            "ClusterMeet" => ::std::option::Option::Some(RequestType::ClusterMeet),
            "ClusterMyId" => ::std::option::Option::Some(RequestType::ClusterMyId),
            "ClusterMyShardId" => ::std::option::Option::Some(RequestType::ClusterMyShardId),
            "ClusterNodes" => ::std::option::Option::Some(RequestType::ClusterNodes),
            "ClusterReplicas" => ::std::option::Option::Some(RequestType::ClusterReplicas),
            "ClusterReplicate" => ::std::option::Option::Some(RequestType::ClusterReplicate),
            "ClusterReset" => ::std::option::Option::Some(RequestType::ClusterReset),
            "ClusterSaveConfig" => ::std::option::Option::Some(RequestType::ClusterSaveConfig),
            "ClusterSetConfigEpoch" => ::std::option::Option::Some(RequestType::ClusterSetConfigEpoch),
            "ClusterSetslot" => ::std::option::Option::Some(RequestType::ClusterSetslot),
            "ClusterShards" => ::std::option::Option::Some(RequestType::ClusterShards),
            "ClusterSlaves" => ::std::option::Option::Some(RequestType::ClusterSlaves),
            "ClusterSlots" => ::std::option::Option::Some(RequestType::ClusterSlots),
            "ReadOnly" => ::std::option::Option::Some(RequestType::ReadOnly),
            "ReadWrite" => ::std::option::Option::Some(RequestType::ReadWrite),
            "Auth" => ::std::option::Option::Some(RequestType::Auth),
            "ClientCaching" => ::std::option::Option::Some(RequestType::ClientCaching),
            "ClientGetName" => ::std::option::Option::Some(RequestType::ClientGetName),
            "ClientGetRedir" => ::std::option::Option::Some(RequestType::ClientGetRedir),
            "ClientId" => ::std::option::Option::Some(RequestType::ClientId),
            "ClientInfo" => ::std::option::Option::Some(RequestType::ClientInfo),
            "ClientKillSimple" => ::std::option::Option::Some(RequestType::ClientKillSimple),
            "ClientKill" => ::std::option::Option::Some(RequestType::ClientKill),
            "ClientList" => ::std::option::Option::Some(RequestType::ClientList),
            "ClientNoEvict" => ::std::option::Option::Some(RequestType::ClientNoEvict),
            "ClientNoTouch" => ::std::option::Option::Some(RequestType::ClientNoTouch),
            "ClientPause" => ::std::option::Option::Some(RequestType::ClientPause),
            "ClientReply" => ::std::option::Option::Some(RequestType::ClientReply),
            "ClientSetInfo" => ::std::option::Option::Some(RequestType::ClientSetInfo),
            "ClientSetName" => ::std::option::Option::Some(RequestType::ClientSetName),
            "ClientTracking" => ::std::option::Option::Some(RequestType::ClientTracking),
            "ClientTrackingInfo" => ::std::option::Option::Some(RequestType::ClientTrackingInfo),
            "ClientUnblock" => ::std::option::Option::Some(RequestType::ClientUnblock),
            "ClientUnpause" => ::std::option::Option::Some(RequestType::ClientUnpause),
            "Echo" => ::std::option::Option::Some(RequestType::Echo),
            "Hello" => ::std::option::Option::Some(RequestType::Hello),
            "Ping" => ::std::option::Option::Some(RequestType::Ping),
            "Quit" => ::std::option::Option::Some(RequestType::Quit),
            "Reset" => ::std::option::Option::Some(RequestType::Reset),
            "Select" => ::std::option::Option::Some(RequestType::Select),
            "Copy" => ::std::option::Option::Some(RequestType::Copy),
            "Del" => ::std::option::Option::Some(RequestType::Del),
            "Dump" => ::std::option::Option::Some(RequestType::Dump),
            "Exists" => ::std::option::Option::Some(RequestType::Exists),
            "Expire" => ::std::option::Option::Some(RequestType::Expire),
            "ExpireAt" => ::std::option::Option::Some(RequestType::ExpireAt),
            "ExpireTime" => ::std::option::Option::Some(RequestType::ExpireTime),
            "Keys" => ::std::option::Option::Some(RequestType::Keys),
            "Migrate" => ::std::option::Option::Some(RequestType::Migrate),
            "Move" => ::std::option::Option::Some(RequestType::Move),
            "ObjectEncoding" => ::std::option::Option::Some(RequestType::ObjectEncoding),
            "ObjectFreq" => ::std::option::Option::Some(RequestType::ObjectFreq),
            "ObjectIdleTime" => ::std::option::Option::Some(RequestType::ObjectIdleTime),
            "ObjectRefCount" => ::std::option::Option::Some(RequestType::ObjectRefCount),
            "Persist" => ::std::option::Option::Some(RequestType::Persist),
            "PExpire" => ::std::option::Option::Some(RequestType::PExpire),
            "PExpireAt" => ::std::option::Option::Some(RequestType::PExpireAt),
            "PExpireTime" => ::std::option::Option::Some(RequestType::PExpireTime),
            "PTTL" => ::std::option::Option::Some(RequestType::PTTL),
            "RandomKey" => ::std::option::Option::Some(RequestType::RandomKey),
            "Rename" => ::std::option::Option::Some(RequestType::Rename),
            "RenameNX" => ::std::option::Option::Some(RequestType::RenameNX),
            "Restore" => ::std::option::Option::Some(RequestType::Restore),
            "Scan" => ::std::option::Option::Some(RequestType::Scan),
            "Sort" => ::std::option::Option::Some(RequestType::Sort),
            "SortReadOnly" => ::std::option::Option::Some(RequestType::SortReadOnly),
            "Touch" => ::std::option::Option::Some(RequestType::Touch),
            "TTL" => ::std::option::Option::Some(RequestType::TTL),
            "Type" => ::std::option::Option::Some(RequestType::Type),
            "Unlink" => ::std::option::Option::Some(RequestType::Unlink),
            "Wait" => ::std::option::Option::Some(RequestType::Wait),
            "WaitAof" => ::std::option::Option::Some(RequestType::WaitAof),
            "GeoAdd" => ::std::option::Option::Some(RequestType::GeoAdd),
            "GeoDist" => ::std::option::Option::Some(RequestType::GeoDist),
            "GeoHash" => ::std::option::Option::Some(RequestType::GeoHash),
            "GeoPos" => ::std::option::Option::Some(RequestType::GeoPos),
            "GeoRadius" => ::std::option::Option::Some(RequestType::GeoRadius),
            "GeoRadiusReadOnly" => ::std::option::Option::Some(RequestType::GeoRadiusReadOnly),
            "GeoRadiusByMember" => ::std::option::Option::Some(RequestType::GeoRadiusByMember),
            "GeoRadiusByMemberReadOnly" => ::std::option::Option::Some(RequestType::GeoRadiusByMemberReadOnly),
            "GeoSearch" => ::std::option::Option::Some(RequestType::GeoSearch),
            "GeoSearchStore" => ::std::option::Option::Some(RequestType::GeoSearchStore),
            "HDel" => ::std::option::Option::Some(RequestType::HDel),
            "HExists" => ::std::option::Option::Some(RequestType::HExists),
            "HGet" => ::std::option::Option::Some(RequestType::HGet),
            "HGetAll" => ::std::option::Option::Some(RequestType::HGetAll),
            "HIncrBy" => ::std::option::Option::Some(RequestType::HIncrBy),
            "HIncrByFloat" => ::std::option::Option::Some(RequestType::HIncrByFloat),
            "HKeys" => ::std::option::Option::Some(RequestType::HKeys),
            "HLen" => ::std::option::Option::Some(RequestType::HLen),
            "HMGet" => ::std::option::Option::Some(RequestType::HMGet),
            "HMSet" => ::std::option::Option::Some(RequestType::HMSet),
            "HRandField" => ::std::option::Option::Some(RequestType::HRandField),
            "HScan" => ::std::option::Option::Some(RequestType::HScan),
            "HSet" => ::std::option::Option::Some(RequestType::HSet),
            "HSetNX" => ::std::option::Option::Some(RequestType::HSetNX),
            "HStrlen" => ::std::option::Option::Some(RequestType::HStrlen),
            "HVals" => ::std::option::Option::Some(RequestType::HVals),
            "PfAdd" => ::std::option::Option::Some(RequestType::PfAdd),
            "PfCount" => ::std::option::Option::Some(RequestType::PfCount),
            "PfMerge" => ::std::option::Option::Some(RequestType::PfMerge),
            "BLMove" => ::std::option::Option::Some(RequestType::BLMove),
            "BLMPop" => ::std::option::Option::Some(RequestType::BLMPop),
            "BLPop" => ::std::option::Option::Some(RequestType::BLPop),
            "BRPop" => ::std::option::Option::Some(RequestType::BRPop),
            "BRPopLPush" => ::std::option::Option::Some(RequestType::BRPopLPush),
            "LIndex" => ::std::option::Option::Some(RequestType::LIndex),
            "LInsert" => ::std::option::Option::Some(RequestType::LInsert),
            "LLen" => ::std::option::Option::Some(RequestType::LLen),
            "LMove" => ::std::option::Option::Some(RequestType::LMove),
            "LMPop" => ::std::option::Option::Some(RequestType::LMPop),
            "LPop" => ::std::option::Option::Some(RequestType::LPop),
            "LPos" => ::std::option::Option::Some(RequestType::LPos),
            "LPush" => ::std::option::Option::Some(RequestType::LPush),
            "LPushX" => ::std::option::Option::Some(RequestType::LPushX),
            "LRange" => ::std::option::Option::Some(RequestType::LRange),
            "LRem" => ::std::option::Option::Some(RequestType::LRem),
            "LSet" => ::std::option::Option::Some(RequestType::LSet),
            "LTrim" => ::std::option::Option::Some(RequestType::LTrim),
            "RPop" => ::std::option::Option::Some(RequestType::RPop),
            "RPopLPush" => ::std::option::Option::Some(RequestType::RPopLPush),
            "RPush" => ::std::option::Option::Some(RequestType::RPush),
            "RPushX" => ::std::option::Option::Some(RequestType::RPushX),
            "PSubscribe" => ::std::option::Option::Some(RequestType::PSubscribe),
            "Publish" => ::std::option::Option::Some(RequestType::Publish),
            "PubSubChannels" => ::std::option::Option::Some(RequestType::PubSubChannels),
            "PubSubNumPat" => ::std::option::Option::Some(RequestType::PubSubNumPat),
            "PubSubNumSub" => ::std::option::Option::Some(RequestType::PubSubNumSub),
            "PubSubShardChannels" => ::std::option::Option::Some(RequestType::PubSubShardChannels),
            "PubSubShardNumSub" => ::std::option::Option::Some(RequestType::PubSubShardNumSub),
            "PUnsubscribe" => ::std::option::Option::Some(RequestType::PUnsubscribe),
            "SPublish" => ::std::option::Option::Some(RequestType::SPublish),
            "SSubscribe" => ::std::option::Option::Some(RequestType::SSubscribe),
            "Subscribe" => ::std::option::Option::Some(RequestType::Subscribe),
            "SUnsubscribe" => ::std::option::Option::Some(RequestType::SUnsubscribe),
            "Unsubscribe" => ::std::option::Option::Some(RequestType::Unsubscribe),
            "Eval" => ::std::option::Option::Some(RequestType::Eval),
            "EvalReadOnly" => ::std::option::Option::Some(RequestType::EvalReadOnly),
            "EvalSha" => ::std::option::Option::Some(RequestType::EvalSha),
            "EvalShaReadOnly" => ::std::option::Option::Some(RequestType::EvalShaReadOnly),
            "FCall" => ::std::option::Option::Some(RequestType::FCall),
            "FCallReadOnly" => ::std::option::Option::Some(RequestType::FCallReadOnly),
            "FunctionDelete" => ::std::option::Option::Some(RequestType::FunctionDelete),
            "FunctionDump" => ::std::option::Option::Some(RequestType::FunctionDump),
            "FunctionFlush" => ::std::option::Option::Some(RequestType::FunctionFlush),
            "FunctionKill" => ::std::option::Option::Some(RequestType::FunctionKill),
            "FunctionList" => ::std::option::Option::Some(RequestType::FunctionList),
            "FunctionLoad" => ::std::option::Option::Some(RequestType::FunctionLoad),
            "FunctionRestore" => ::std::option::Option::Some(RequestType::FunctionRestore),
            "FunctionStats" => ::std::option::Option::Some(RequestType::FunctionStats),
            "ScriptDebug" => ::std::option::Option::Some(RequestType::ScriptDebug),
            "ScriptExists" => ::std::option::Option::Some(RequestType::ScriptExists),
            "ScriptFlush" => ::std::option::Option::Some(RequestType::ScriptFlush),
            "ScriptKill" => ::std::option::Option::Some(RequestType::ScriptKill),
            "ScriptLoad" => ::std::option::Option::Some(RequestType::ScriptLoad),
            "ScriptShow" => ::std::option::Option::Some(RequestType::ScriptShow),
            "AclCat" => ::std::option::Option::Some(RequestType::AclCat),
            "AclDelUser" => ::std::option::Option::Some(RequestType::AclDelUser),
            "AclDryRun" => ::std::option::Option::Some(RequestType::AclDryRun),
            "AclGenPass" => ::std::option::Option::Some(RequestType::AclGenPass),
            "AclGetUser" => ::std::option::Option::Some(RequestType::AclGetUser),
            "AclList" => ::std::option::Option::Some(RequestType::AclList),
            "AclLoad" => ::std::option::Option::Some(RequestType::AclLoad),
            "AclLog" => ::std::option::Option::Some(RequestType::AclLog),
            "AclSave" => ::std::option::Option::Some(RequestType::AclSave),
            "AclSetSser" => ::std::option::Option::Some(RequestType::AclSetSser),
            "AclUsers" => ::std::option::Option::Some(RequestType::AclUsers),
            "AclWhoami" => ::std::option::Option::Some(RequestType::AclWhoami),
            "BgRewriteAof" => ::std::option::Option::Some(RequestType::BgRewriteAof),
            "BgSave" => ::std::option::Option::Some(RequestType::BgSave),
            "Command_" => ::std::option::Option::Some(RequestType::Command_),
            "CommandCount" => ::std::option::Option::Some(RequestType::CommandCount),
            "CommandDocs" => ::std::option::Option::Some(RequestType::CommandDocs),
            "CommandGetKeys" => ::std::option::Option::Some(RequestType::CommandGetKeys),
            "CommandGetKeysAndFlags" => ::std::option::Option::Some(RequestType::CommandGetKeysAndFlags),
            "CommandInfo" => ::std::option::Option::Some(RequestType::CommandInfo),
            "CommandList" => ::std::option::Option::Some(RequestType::CommandList),
            "ConfigGet" => ::std::option::Option::Some(RequestType::ConfigGet),
            "ConfigResetStat" => ::std::option::Option::Some(RequestType::ConfigResetStat),
            "ConfigRewrite" => ::std::option::Option::Some(RequestType::ConfigRewrite),
            "ConfigSet" => ::std::option::Option::Some(RequestType::ConfigSet),
            "DBSize" => ::std::option::Option::Some(RequestType::DBSize),
            "FailOver" => ::std::option::Option::Some(RequestType::FailOver),
            "FlushAll" => ::std::option::Option::Some(RequestType::FlushAll),
            "FlushDB" => ::std::option::Option::Some(RequestType::FlushDB),
            "Info" => ::std::option::Option::Some(RequestType::Info),
            "LastSave" => ::std::option::Option::Some(RequestType::LastSave),
            "LatencyDoctor" => ::std::option::Option::Some(RequestType::LatencyDoctor),
            "LatencyGraph" => ::std::option::Option::Some(RequestType::LatencyGraph),
            "LatencyHistogram" => ::std::option::Option::Some(RequestType::LatencyHistogram),
            "LatencyHistory" => ::std::option::Option::Some(RequestType::LatencyHistory),
            "LatencyLatest" => ::std::option::Option::Some(RequestType::LatencyLatest),
            "LatencyReset" => ::std::option::Option::Some(RequestType::LatencyReset),
            "Lolwut" => ::std::option::Option::Some(RequestType::Lolwut),
            "MemoryDoctor" => ::std::option::Option::Some(RequestType::MemoryDoctor),
            "MemoryMallocStats" => ::std::option::Option::Some(RequestType::MemoryMallocStats),
            "MemoryPurge" => ::std::option::Option::Some(RequestType::MemoryPurge),
            "MemoryStats" => ::std::option::Option::Some(RequestType::MemoryStats),
            "MemoryUsage" => ::std::option::Option::Some(RequestType::MemoryUsage),
            "ModuleList" => ::std::option::Option::Some(RequestType::ModuleList),
            "ModuleLoad" => ::std::option::Option::Some(RequestType::ModuleLoad),
            "ModuleLoadEx" => ::std::option::Option::Some(RequestType::ModuleLoadEx),
            "ModuleUnload" => ::std::option::Option::Some(RequestType::ModuleUnload),
            "Monitor" => ::std::option::Option::Some(RequestType::Monitor),
            "PSync" => ::std::option::Option::Some(RequestType::PSync),
            "ReplConf" => ::std::option::Option::Some(RequestType::ReplConf),
            "ReplicaOf" => ::std::option::Option::Some(RequestType::ReplicaOf),
            "RestoreAsking" => ::std::option::Option::Some(RequestType::RestoreAsking),
            "Role" => ::std::option::Option::Some(RequestType::Role),
            "Save" => ::std::option::Option::Some(RequestType::Save),
            "ShutDown" => ::std::option::Option::Some(RequestType::ShutDown),
            "SlaveOf" => ::std::option::Option::Some(RequestType::SlaveOf),
            "SlowLogGet" => ::std::option::Option::Some(RequestType::SlowLogGet),
            "SlowLogLen" => ::std::option::Option::Some(RequestType::SlowLogLen),
            "SlowLogReset" => ::std::option::Option::Some(RequestType::SlowLogReset),
            "SwapDb" => ::std::option::Option::Some(RequestType::SwapDb),
            "Sync" => ::std::option::Option::Some(RequestType::Sync),
            "Time" => ::std::option::Option::Some(RequestType::Time),
            "SAdd" => ::std::option::Option::Some(RequestType::SAdd),
            "SCard" => ::std::option::Option::Some(RequestType::SCard),
            "SDiff" => ::std::option::Option::Some(RequestType::SDiff),
            "SDiffStore" => ::std::option::Option::Some(RequestType::SDiffStore),
            "SInter" => ::std::option::Option::Some(RequestType::SInter),
            "SInterCard" => ::std::option::Option::Some(RequestType::SInterCard),
            "SInterStore" => ::std::option::Option::Some(RequestType::SInterStore),
            "SIsMember" => ::std::option::Option::Some(RequestType::SIsMember),
            "SMembers" => ::std::option::Option::Some(RequestType::SMembers),
            "SMIsMember" => ::std::option::Option::Some(RequestType::SMIsMember),
            "SMove" => ::std::option::Option::Some(RequestType::SMove),
            "SPop" => ::std::option::Option::Some(RequestType::SPop),
            "SRandMember" => ::std::option::Option::Some(RequestType::SRandMember),
            "SRem" => ::std::option::Option::Some(RequestType::SRem),
            "SScan" => ::std::option::Option::Some(RequestType::SScan),
            "SUnion" => ::std::option::Option::Some(RequestType::SUnion),
            "SUnionStore" => ::std::option::Option::Some(RequestType::SUnionStore),
            "BZMPop" => ::std::option::Option::Some(RequestType::BZMPop),
            "BZPopMax" => ::std::option::Option::Some(RequestType::BZPopMax),
            "BZPopMin" => ::std::option::Option::Some(RequestType::BZPopMin),
            "ZAdd" => ::std::option::Option::Some(RequestType::ZAdd),
            "ZCard" => ::std::option::Option::Some(RequestType::ZCard),
            "ZCount" => ::std::option::Option::Some(RequestType::ZCount),
            "ZDiff" => ::std::option::Option::Some(RequestType::ZDiff),
            "ZDiffStore" => ::std::option::Option::Some(RequestType::ZDiffStore),
            "ZIncrBy" => ::std::option::Option::Some(RequestType::ZIncrBy),
            "ZInter" => ::std::option::Option::Some(RequestType::ZInter),
            "ZInterCard" => ::std::option::Option::Some(RequestType::ZInterCard),
            "ZInterStore" => ::std::option::Option::Some(RequestType::ZInterStore),
            "ZLexCount" => ::std::option::Option::Some(RequestType::ZLexCount),
            "ZMPop" => ::std::option::Option::Some(RequestType::ZMPop),
            "ZMScore" => ::std::option::Option::Some(RequestType::ZMScore),
            "ZPopMax" => ::std::option::Option::Some(RequestType::ZPopMax),
            "ZPopMin" => ::std::option::Option::Some(RequestType::ZPopMin),
            "ZRandMember" => ::std::option::Option::Some(RequestType::ZRandMember),
            "ZRange" => ::std::option::Option::Some(RequestType::ZRange),
            "ZRangeByLex" => ::std::option::Option::Some(RequestType::ZRangeByLex),
            "ZRangeByScore" => ::std::option::Option::Some(RequestType::ZRangeByScore),
            "ZRangeStore" => ::std::option::Option::Some(RequestType::ZRangeStore),
            "ZRank" => ::std::option::Option::Some(RequestType::ZRank),
            "ZRem" => ::std::option::Option::Some(RequestType::ZRem),
            "ZRemRangeByLex" => ::std::option::Option::Some(RequestType::ZRemRangeByLex),
            "ZRemRangeByRank" => ::std::option::Option::Some(RequestType::ZRemRangeByRank),
            "ZRemRangeByScore" => ::std::option::Option::Some(RequestType::ZRemRangeByScore),
            "ZRevRange" => ::std::option::Option::Some(RequestType::ZRevRange),
            "ZRevRangeByLex" => ::std::option::Option::Some(RequestType::ZRevRangeByLex),
            "ZRevRangeByScore" => ::std::option::Option::Some(RequestType::ZRevRangeByScore),
            "ZRevRank" => ::std::option::Option::Some(RequestType::ZRevRank),
            "ZScan" => ::std::option::Option::Some(RequestType::ZScan),
            "ZScore" => ::std::option::Option::Some(RequestType::ZScore),
            "ZUnion" => ::std::option::Option::Some(RequestType::ZUnion),
            "ZUnionStore" => ::std::option::Option::Some(RequestType::ZUnionStore),
            "XAck" => ::std::option::Option::Some(RequestType::XAck),
            "XAdd" => ::std::option::Option::Some(RequestType::XAdd),
            "XAutoClaim" => ::std::option::Option::Some(RequestType::XAutoClaim),
            "XClaim" => ::std::option::Option::Some(RequestType::XClaim),
            "XDel" => ::std::option::Option::Some(RequestType::XDel),
            "XGroupCreate" => ::std::option::Option::Some(RequestType::XGroupCreate),
            "XGroupCreateConsumer" => ::std::option::Option::Some(RequestType::XGroupCreateConsumer),
            "XGroupDelConsumer" => ::std::option::Option::Some(RequestType::XGroupDelConsumer),
            "XGroupDestroy" => ::std::option::Option::Some(RequestType::XGroupDestroy),
            "XGroupSetId" => ::std::option::Option::Some(RequestType::XGroupSetId),
            "XInfoConsumers" => ::std::option::Option::Some(RequestType::XInfoConsumers),
            "XInfoGroups" => ::std::option::Option::Some(RequestType::XInfoGroups),
            "XInfoStream" => ::std::option::Option::Some(RequestType::XInfoStream),
            "XLen" => ::std::option::Option::Some(RequestType::XLen),
            "XPending" => ::std::option::Option::Some(RequestType::XPending),
            "XRange" => ::std::option::Option::Some(RequestType::XRange),
            "XRead" => ::std::option::Option::Some(RequestType::XRead),
            "XReadGroup" => ::std::option::Option::Some(RequestType::XReadGroup),
            "XRevRange" => ::std::option::Option::Some(RequestType::XRevRange),
            "XSetId" => ::std::option::Option::Some(RequestType::XSetId),
            "XTrim" => ::std::option::Option::Some(RequestType::XTrim),
            "Append" => ::std::option::Option::Some(RequestType::Append),
            "Decr" => ::std::option::Option::Some(RequestType::Decr),
            "DecrBy" => ::std::option::Option::Some(RequestType::DecrBy),
            "Get" => ::std::option::Option::Some(RequestType::Get),
            "GetDel" => ::std::option::Option::Some(RequestType::GetDel),
            "GetEx" => ::std::option::Option::Some(RequestType::GetEx),
            "GetRange" => ::std::option::Option::Some(RequestType::GetRange),
            "GetSet" => ::std::option::Option::Some(RequestType::GetSet),
            "Incr" => ::std::option::Option::Some(RequestType::Incr),
            "IncrBy" => ::std::option::Option::Some(RequestType::IncrBy),
            "IncrByFloat" => ::std::option::Option::Some(RequestType::IncrByFloat),
            "LCS" => ::std::option::Option::Some(RequestType::LCS),
            "MGet" => ::std::option::Option::Some(RequestType::MGet),
            "MSet" => ::std::option::Option::Some(RequestType::MSet),
            "MSetNX" => ::std::option::Option::Some(RequestType::MSetNX),
            "PSetEx" => ::std::option::Option::Some(RequestType::PSetEx),
            "Set" => ::std::option::Option::Some(RequestType::Set),
            "SetEx" => ::std::option::Option::Some(RequestType::SetEx),
            "SetNX" => ::std::option::Option::Some(RequestType::SetNX),
            "SetRange" => ::std::option::Option::Some(RequestType::SetRange),
            "Strlen" => ::std::option::Option::Some(RequestType::Strlen),
            "Substr" => ::std::option::Option::Some(RequestType::Substr),
            "Discard" => ::std::option::Option::Some(RequestType::Discard),
            "Exec" => ::std::option::Option::Some(RequestType::Exec),
            "Multi" => ::std::option::Option::Some(RequestType::Multi),
            "UnWatch" => ::std::option::Option::Some(RequestType::UnWatch),
            "Watch" => ::std::option::Option::Some(RequestType::Watch),
            "JsonArrAppend" => ::std::option::Option::Some(RequestType::JsonArrAppend),
            "JsonArrIndex" => ::std::option::Option::Some(RequestType::JsonArrIndex),
            "JsonArrInsert" => ::std::option::Option::Some(RequestType::JsonArrInsert),
            "JsonArrLen" => ::std::option::Option::Some(RequestType::JsonArrLen),
            "JsonArrPop" => ::std::option::Option::Some(RequestType::JsonArrPop),
            "JsonArrTrim" => ::std::option::Option::Some(RequestType::JsonArrTrim),
            "JsonClear" => ::std::option::Option::Some(RequestType::JsonClear),
            "JsonDebug" => ::std::option::Option::Some(RequestType::JsonDebug),
            "JsonDel" => ::std::option::Option::Some(RequestType::JsonDel),
            "JsonForget" => ::std::option::Option::Some(RequestType::JsonForget),
            "JsonGet" => ::std::option::Option::Some(RequestType::JsonGet),
            "JsonMGet" => ::std::option::Option::Some(RequestType::JsonMGet),
            "JsonNumIncrBy" => ::std::option::Option::Some(RequestType::JsonNumIncrBy),
            "JsonNumMultBy" => ::std::option::Option::Some(RequestType::JsonNumMultBy),
            "JsonObjKeys" => ::std::option::Option::Some(RequestType::JsonObjKeys),
            "JsonObjLen" => ::std::option::Option::Some(RequestType::JsonObjLen),
            "JsonResp" => ::std::option::Option::Some(RequestType::JsonResp),
            "JsonSet" => ::std::option::Option::Some(RequestType::JsonSet),
            "JsonStrAppend" => ::std::option::Option::Some(RequestType::JsonStrAppend),
            "JsonStrLen" => ::std::option::Option::Some(RequestType::JsonStrLen),
            "JsonToggle" => ::std::option::Option::Some(RequestType::JsonToggle),
            "JsonType" => ::std::option::Option::Some(RequestType::JsonType),
            "FtList" => ::std::option::Option::Some(RequestType::FtList),
            "FtAggregate" => ::std::option::Option::Some(RequestType::FtAggregate),
            "FtAliasAdd" => ::std::option::Option::Some(RequestType::FtAliasAdd),
            "FtAliasDel" => ::std::option::Option::Some(RequestType::FtAliasDel),
            "FtAliasList" => ::std::option::Option::Some(RequestType::FtAliasList),
            "FtAliasUpdate" => ::std::option::Option::Some(RequestType::FtAliasUpdate),
            "FtCreate" => ::std::option::Option::Some(RequestType::FtCreate),
            "FtDropIndex" => ::std::option::Option::Some(RequestType::FtDropIndex),
            "FtExplain" => ::std::option::Option::Some(RequestType::FtExplain),
            "FtExplainCli" => ::std::option::Option::Some(RequestType::FtExplainCli),
            "FtInfo" => ::std::option::Option::Some(RequestType::FtInfo),
            "FtProfile" => ::std::option::Option::Some(RequestType::FtProfile),
            "FtSearch" => ::std::option::Option::Some(RequestType::FtSearch),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RequestType] = &[
        RequestType::InvalidRequest,
        RequestType::CustomCommand,
        RequestType::BitCount,
        RequestType::BitField,
        RequestType::BitFieldReadOnly,
        RequestType::BitOp,
        RequestType::BitPos,
        RequestType::GetBit,
        RequestType::SetBit,
        RequestType::Asking,
        RequestType::ClusterAddSlots,
        RequestType::ClusterAddSlotsRange,
        RequestType::ClusterBumpEpoch,
        RequestType::ClusterCountFailureReports,
        RequestType::ClusterCountKeysInSlot,
        RequestType::ClusterDelSlots,
        RequestType::ClusterDelSlotsRange,
        RequestType::ClusterFailover,
        RequestType::ClusterFlushSlots,
        RequestType::ClusterForget,
        RequestType::ClusterGetKeysInSlot,
        RequestType::ClusterInfo,
        RequestType::ClusterKeySlot,
        RequestType::ClusterLinks,
        RequestType::ClusterMeet,
        RequestType::ClusterMyId,
        RequestType::ClusterMyShardId,
        RequestType::ClusterNodes,
        RequestType::ClusterReplicas,
        RequestType::ClusterReplicate,
        RequestType::ClusterReset,
        RequestType::ClusterSaveConfig,
        RequestType::ClusterSetConfigEpoch,
        RequestType::ClusterSetslot,
        RequestType::ClusterShards,
        RequestType::ClusterSlaves,
        RequestType::ClusterSlots,
        RequestType::ReadOnly,
        RequestType::ReadWrite,
        RequestType::Auth,
        RequestType::ClientCaching,
        RequestType::ClientGetName,
        RequestType::ClientGetRedir,
        RequestType::ClientId,
        RequestType::ClientInfo,
        RequestType::ClientKillSimple,
        RequestType::ClientKill,
        RequestType::ClientList,
        RequestType::ClientNoEvict,
        RequestType::ClientNoTouch,
        RequestType::ClientPause,
        RequestType::ClientReply,
        RequestType::ClientSetInfo,
        RequestType::ClientSetName,
        RequestType::ClientTracking,
        RequestType::ClientTrackingInfo,
        RequestType::ClientUnblock,
        RequestType::ClientUnpause,
        RequestType::Echo,
        RequestType::Hello,
        RequestType::Ping,
        RequestType::Quit,
        RequestType::Reset,
        RequestType::Select,
        RequestType::Copy,
        RequestType::Del,
        RequestType::Dump,
        RequestType::Exists,
        RequestType::Expire,
        RequestType::ExpireAt,
        RequestType::ExpireTime,
        RequestType::Keys,
        RequestType::Migrate,
        RequestType::Move,
        RequestType::ObjectEncoding,
        RequestType::ObjectFreq,
        RequestType::ObjectIdleTime,
        RequestType::ObjectRefCount,
        RequestType::Persist,
        RequestType::PExpire,
        RequestType::PExpireAt,
        RequestType::PExpireTime,
        RequestType::PTTL,
        RequestType::RandomKey,
        RequestType::Rename,
        RequestType::RenameNX,
        RequestType::Restore,
        RequestType::Scan,
        RequestType::Sort,
        RequestType::SortReadOnly,
        RequestType::Touch,
        RequestType::TTL,
        RequestType::Type,
        RequestType::Unlink,
        RequestType::Wait,
        RequestType::WaitAof,
        RequestType::GeoAdd,
        RequestType::GeoDist,
        RequestType::GeoHash,
        RequestType::GeoPos,
        RequestType::GeoRadius,
        RequestType::GeoRadiusReadOnly,
        RequestType::GeoRadiusByMember,
        RequestType::GeoRadiusByMemberReadOnly,
        RequestType::GeoSearch,
        RequestType::GeoSearchStore,
        RequestType::HDel,
        RequestType::HExists,
        RequestType::HGet,
        RequestType::HGetAll,
        RequestType::HIncrBy,
        RequestType::HIncrByFloat,
        RequestType::HKeys,
        RequestType::HLen,
        RequestType::HMGet,
        RequestType::HMSet,
        RequestType::HRandField,
        RequestType::HScan,
        RequestType::HSet,
        RequestType::HSetNX,
        RequestType::HStrlen,
        RequestType::HVals,
        RequestType::PfAdd,
        RequestType::PfCount,
        RequestType::PfMerge,
        RequestType::BLMove,
        RequestType::BLMPop,
        RequestType::BLPop,
        RequestType::BRPop,
        RequestType::BRPopLPush,
        RequestType::LIndex,
        RequestType::LInsert,
        RequestType::LLen,
        RequestType::LMove,
        RequestType::LMPop,
        RequestType::LPop,
        RequestType::LPos,
        RequestType::LPush,
        RequestType::LPushX,
        RequestType::LRange,
        RequestType::LRem,
        RequestType::LSet,
        RequestType::LTrim,
        RequestType::RPop,
        RequestType::RPopLPush,
        RequestType::RPush,
        RequestType::RPushX,
        RequestType::PSubscribe,
        RequestType::Publish,
        RequestType::PubSubChannels,
        RequestType::PubSubNumPat,
        RequestType::PubSubNumSub,
        RequestType::PubSubShardChannels,
        RequestType::PubSubShardNumSub,
        RequestType::PUnsubscribe,
        RequestType::SPublish,
        RequestType::SSubscribe,
        RequestType::Subscribe,
        RequestType::SUnsubscribe,
        RequestType::Unsubscribe,
        RequestType::Eval,
        RequestType::EvalReadOnly,
        RequestType::EvalSha,
        RequestType::EvalShaReadOnly,
        RequestType::FCall,
        RequestType::FCallReadOnly,
        RequestType::FunctionDelete,
        RequestType::FunctionDump,
        RequestType::FunctionFlush,
        RequestType::FunctionKill,
        RequestType::FunctionList,
        RequestType::FunctionLoad,
        RequestType::FunctionRestore,
        RequestType::FunctionStats,
        RequestType::ScriptDebug,
        RequestType::ScriptExists,
        RequestType::ScriptFlush,
        RequestType::ScriptKill,
        RequestType::ScriptLoad,
        RequestType::ScriptShow,
        RequestType::AclCat,
        RequestType::AclDelUser,
        RequestType::AclDryRun,
        RequestType::AclGenPass,
        RequestType::AclGetUser,
        RequestType::AclList,
        RequestType::AclLoad,
        RequestType::AclLog,
        RequestType::AclSave,
        RequestType::AclSetSser,
        RequestType::AclUsers,
        RequestType::AclWhoami,
        RequestType::BgRewriteAof,
        RequestType::BgSave,
        RequestType::Command_,
        RequestType::CommandCount,
        RequestType::CommandDocs,
        RequestType::CommandGetKeys,
        RequestType::CommandGetKeysAndFlags,
        RequestType::CommandInfo,
        RequestType::CommandList,
        RequestType::ConfigGet,
        RequestType::ConfigResetStat,
        RequestType::ConfigRewrite,
        RequestType::ConfigSet,
        RequestType::DBSize,
        RequestType::FailOver,
        RequestType::FlushAll,
        RequestType::FlushDB,
        RequestType::Info,
        RequestType::LastSave,
        RequestType::LatencyDoctor,
        RequestType::LatencyGraph,
        RequestType::LatencyHistogram,
        RequestType::LatencyHistory,
        RequestType::LatencyLatest,
        RequestType::LatencyReset,
        RequestType::Lolwut,
        RequestType::MemoryDoctor,
        RequestType::MemoryMallocStats,
        RequestType::MemoryPurge,
        RequestType::MemoryStats,
        RequestType::MemoryUsage,
        RequestType::ModuleList,
        RequestType::ModuleLoad,
        RequestType::ModuleLoadEx,
        RequestType::ModuleUnload,
        RequestType::Monitor,
        RequestType::PSync,
        RequestType::ReplConf,
        RequestType::ReplicaOf,
        RequestType::RestoreAsking,
        RequestType::Role,
        RequestType::Save,
        RequestType::ShutDown,
        RequestType::SlaveOf,
        RequestType::SlowLogGet,
        RequestType::SlowLogLen,
        RequestType::SlowLogReset,
        RequestType::SwapDb,
        RequestType::Sync,
        RequestType::Time,
        RequestType::SAdd,
        RequestType::SCard,
        RequestType::SDiff,
        RequestType::SDiffStore,
        RequestType::SInter,
        RequestType::SInterCard,
        RequestType::SInterStore,
        RequestType::SIsMember,
        RequestType::SMembers,
        RequestType::SMIsMember,
        RequestType::SMove,
        RequestType::SPop,
        RequestType::SRandMember,
        RequestType::SRem,
        RequestType::SScan,
        RequestType::SUnion,
        RequestType::SUnionStore,
        RequestType::BZMPop,
        RequestType::BZPopMax,
        RequestType::BZPopMin,
        RequestType::ZAdd,
        RequestType::ZCard,
        RequestType::ZCount,
        RequestType::ZDiff,
        RequestType::ZDiffStore,
        RequestType::ZIncrBy,
        RequestType::ZInter,
        RequestType::ZInterCard,
        RequestType::ZInterStore,
        RequestType::ZLexCount,
        RequestType::ZMPop,
        RequestType::ZMScore,
        RequestType::ZPopMax,
        RequestType::ZPopMin,
        RequestType::ZRandMember,
        RequestType::ZRange,
        RequestType::ZRangeByLex,
        RequestType::ZRangeByScore,
        RequestType::ZRangeStore,
        RequestType::ZRank,
        RequestType::ZRem,
        RequestType::ZRemRangeByLex,
        RequestType::ZRemRangeByRank,
        RequestType::ZRemRangeByScore,
        RequestType::ZRevRange,
        RequestType::ZRevRangeByLex,
        RequestType::ZRevRangeByScore,
        RequestType::ZRevRank,
        RequestType::ZScan,
        RequestType::ZScore,
        RequestType::ZUnion,
        RequestType::ZUnionStore,
        RequestType::XAck,
        RequestType::XAdd,
        RequestType::XAutoClaim,
        RequestType::XClaim,
        RequestType::XDel,
        RequestType::XGroupCreate,
        RequestType::XGroupCreateConsumer,
        RequestType::XGroupDelConsumer,
        RequestType::XGroupDestroy,
        RequestType::XGroupSetId,
        RequestType::XInfoConsumers,
        RequestType::XInfoGroups,
        RequestType::XInfoStream,
        RequestType::XLen,
        RequestType::XPending,
        RequestType::XRange,
        RequestType::XRead,
        RequestType::XReadGroup,
        RequestType::XRevRange,
        RequestType::XSetId,
        RequestType::XTrim,
        RequestType::Append,
        RequestType::Decr,
        RequestType::DecrBy,
        RequestType::Get,
        RequestType::GetDel,
        RequestType::GetEx,
        RequestType::GetRange,
        RequestType::GetSet,
        RequestType::Incr,
        RequestType::IncrBy,
        RequestType::IncrByFloat,
        RequestType::LCS,
        RequestType::MGet,
        RequestType::MSet,
        RequestType::MSetNX,
        RequestType::PSetEx,
        RequestType::Set,
        RequestType::SetEx,
        RequestType::SetNX,
        RequestType::SetRange,
        RequestType::Strlen,
        RequestType::Substr,
        RequestType::Discard,
        RequestType::Exec,
        RequestType::Multi,
        RequestType::UnWatch,
        RequestType::Watch,
        RequestType::JsonArrAppend,
        RequestType::JsonArrIndex,
        RequestType::JsonArrInsert,
        RequestType::JsonArrLen,
        RequestType::JsonArrPop,
        RequestType::JsonArrTrim,
        RequestType::JsonClear,
        RequestType::JsonDebug,
        RequestType::JsonDel,
        RequestType::JsonForget,
        RequestType::JsonGet,
        RequestType::JsonMGet,
        RequestType::JsonNumIncrBy,
        RequestType::JsonNumMultBy,
        RequestType::JsonObjKeys,
        RequestType::JsonObjLen,
        RequestType::JsonResp,
        RequestType::JsonSet,
        RequestType::JsonStrAppend,
        RequestType::JsonStrLen,
        RequestType::JsonToggle,
        RequestType::JsonType,
        RequestType::FtList,
        RequestType::FtAggregate,
        RequestType::FtAliasAdd,
        RequestType::FtAliasDel,
        RequestType::FtAliasList,
        RequestType::FtAliasUpdate,
        RequestType::FtCreate,
        RequestType::FtDropIndex,
        RequestType::FtExplain,
        RequestType::FtExplainCli,
        RequestType::FtInfo,
        RequestType::FtProfile,
        RequestType::FtSearch,
    ];
}

impl ::protobuf::EnumFull for RequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            RequestType::InvalidRequest => 0,
            RequestType::CustomCommand => 1,
            RequestType::BitCount => 2,
            RequestType::BitField => 3,
            RequestType::BitFieldReadOnly => 4,
            RequestType::BitOp => 5,
            RequestType::BitPos => 6,
            RequestType::GetBit => 7,
            RequestType::SetBit => 8,
            RequestType::Asking => 9,
            RequestType::ClusterAddSlots => 10,
            RequestType::ClusterAddSlotsRange => 11,
            RequestType::ClusterBumpEpoch => 12,
            RequestType::ClusterCountFailureReports => 13,
            RequestType::ClusterCountKeysInSlot => 14,
            RequestType::ClusterDelSlots => 15,
            RequestType::ClusterDelSlotsRange => 16,
            RequestType::ClusterFailover => 17,
            RequestType::ClusterFlushSlots => 18,
            RequestType::ClusterForget => 19,
            RequestType::ClusterGetKeysInSlot => 20,
            RequestType::ClusterInfo => 21,
            RequestType::ClusterKeySlot => 22,
            RequestType::ClusterLinks => 23,
            RequestType::ClusterMeet => 24,
            RequestType::ClusterMyId => 25,
            RequestType::ClusterMyShardId => 26,
            RequestType::ClusterNodes => 27,
            RequestType::ClusterReplicas => 28,
            RequestType::ClusterReplicate => 29,
            RequestType::ClusterReset => 30,
            RequestType::ClusterSaveConfig => 31,
            RequestType::ClusterSetConfigEpoch => 32,
            RequestType::ClusterSetslot => 33,
            RequestType::ClusterShards => 34,
            RequestType::ClusterSlaves => 35,
            RequestType::ClusterSlots => 36,
            RequestType::ReadOnly => 37,
            RequestType::ReadWrite => 38,
            RequestType::Auth => 39,
            RequestType::ClientCaching => 40,
            RequestType::ClientGetName => 41,
            RequestType::ClientGetRedir => 42,
            RequestType::ClientId => 43,
            RequestType::ClientInfo => 44,
            RequestType::ClientKillSimple => 45,
            RequestType::ClientKill => 46,
            RequestType::ClientList => 47,
            RequestType::ClientNoEvict => 48,
            RequestType::ClientNoTouch => 49,
            RequestType::ClientPause => 50,
            RequestType::ClientReply => 51,
            RequestType::ClientSetInfo => 52,
            RequestType::ClientSetName => 53,
            RequestType::ClientTracking => 54,
            RequestType::ClientTrackingInfo => 55,
            RequestType::ClientUnblock => 56,
            RequestType::ClientUnpause => 57,
            RequestType::Echo => 58,
            RequestType::Hello => 59,
            RequestType::Ping => 60,
            RequestType::Quit => 61,
            RequestType::Reset => 62,
            RequestType::Select => 63,
            RequestType::Copy => 64,
            RequestType::Del => 65,
            RequestType::Dump => 66,
            RequestType::Exists => 67,
            RequestType::Expire => 68,
            RequestType::ExpireAt => 69,
            RequestType::ExpireTime => 70,
            RequestType::Keys => 71,
            RequestType::Migrate => 72,
            RequestType::Move => 73,
            RequestType::ObjectEncoding => 74,
            RequestType::ObjectFreq => 75,
            RequestType::ObjectIdleTime => 76,
            RequestType::ObjectRefCount => 77,
            RequestType::Persist => 78,
            RequestType::PExpire => 79,
            RequestType::PExpireAt => 80,
            RequestType::PExpireTime => 81,
            RequestType::PTTL => 82,
            RequestType::RandomKey => 83,
            RequestType::Rename => 84,
            RequestType::RenameNX => 85,
            RequestType::Restore => 86,
            RequestType::Scan => 87,
            RequestType::Sort => 88,
            RequestType::SortReadOnly => 89,
            RequestType::Touch => 90,
            RequestType::TTL => 91,
            RequestType::Type => 92,
            RequestType::Unlink => 93,
            RequestType::Wait => 94,
            RequestType::WaitAof => 95,
            RequestType::GeoAdd => 96,
            RequestType::GeoDist => 97,
            RequestType::GeoHash => 98,
            RequestType::GeoPos => 99,
            RequestType::GeoRadius => 100,
            RequestType::GeoRadiusReadOnly => 101,
            RequestType::GeoRadiusByMember => 102,
            RequestType::GeoRadiusByMemberReadOnly => 103,
            RequestType::GeoSearch => 104,
            RequestType::GeoSearchStore => 105,
            RequestType::HDel => 106,
            RequestType::HExists => 107,
            RequestType::HGet => 108,
            RequestType::HGetAll => 109,
            RequestType::HIncrBy => 110,
            RequestType::HIncrByFloat => 111,
            RequestType::HKeys => 112,
            RequestType::HLen => 113,
            RequestType::HMGet => 114,
            RequestType::HMSet => 115,
            RequestType::HRandField => 116,
            RequestType::HScan => 117,
            RequestType::HSet => 118,
            RequestType::HSetNX => 119,
            RequestType::HStrlen => 120,
            RequestType::HVals => 121,
            RequestType::PfAdd => 122,
            RequestType::PfCount => 123,
            RequestType::PfMerge => 124,
            RequestType::BLMove => 125,
            RequestType::BLMPop => 126,
            RequestType::BLPop => 127,
            RequestType::BRPop => 128,
            RequestType::BRPopLPush => 129,
            RequestType::LIndex => 130,
            RequestType::LInsert => 131,
            RequestType::LLen => 132,
            RequestType::LMove => 133,
            RequestType::LMPop => 134,
            RequestType::LPop => 135,
            RequestType::LPos => 136,
            RequestType::LPush => 137,
            RequestType::LPushX => 138,
            RequestType::LRange => 139,
            RequestType::LRem => 140,
            RequestType::LSet => 141,
            RequestType::LTrim => 142,
            RequestType::RPop => 143,
            RequestType::RPopLPush => 144,
            RequestType::RPush => 145,
            RequestType::RPushX => 146,
            RequestType::PSubscribe => 147,
            RequestType::Publish => 148,
            RequestType::PubSubChannels => 149,
            RequestType::PubSubNumPat => 150,
            RequestType::PubSubNumSub => 151,
            RequestType::PubSubShardChannels => 152,
            RequestType::PubSubShardNumSub => 153,
            RequestType::PUnsubscribe => 154,
            RequestType::SPublish => 155,
            RequestType::SSubscribe => 156,
            RequestType::Subscribe => 157,
            RequestType::SUnsubscribe => 158,
            RequestType::Unsubscribe => 159,
            RequestType::Eval => 160,
            RequestType::EvalReadOnly => 161,
            RequestType::EvalSha => 162,
            RequestType::EvalShaReadOnly => 163,
            RequestType::FCall => 164,
            RequestType::FCallReadOnly => 165,
            RequestType::FunctionDelete => 166,
            RequestType::FunctionDump => 167,
            RequestType::FunctionFlush => 168,
            RequestType::FunctionKill => 169,
            RequestType::FunctionList => 170,
            RequestType::FunctionLoad => 171,
            RequestType::FunctionRestore => 172,
            RequestType::FunctionStats => 173,
            RequestType::ScriptDebug => 174,
            RequestType::ScriptExists => 175,
            RequestType::ScriptFlush => 176,
            RequestType::ScriptKill => 177,
            RequestType::ScriptLoad => 178,
            RequestType::ScriptShow => 179,
            RequestType::AclCat => 180,
            RequestType::AclDelUser => 181,
            RequestType::AclDryRun => 182,
            RequestType::AclGenPass => 183,
            RequestType::AclGetUser => 184,
            RequestType::AclList => 185,
            RequestType::AclLoad => 186,
            RequestType::AclLog => 187,
            RequestType::AclSave => 188,
            RequestType::AclSetSser => 189,
            RequestType::AclUsers => 190,
            RequestType::AclWhoami => 191,
            RequestType::BgRewriteAof => 192,
            RequestType::BgSave => 193,
            RequestType::Command_ => 194,
            RequestType::CommandCount => 195,
            RequestType::CommandDocs => 196,
            RequestType::CommandGetKeys => 197,
            RequestType::CommandGetKeysAndFlags => 198,
            RequestType::CommandInfo => 199,
            RequestType::CommandList => 200,
            RequestType::ConfigGet => 201,
            RequestType::ConfigResetStat => 202,
            RequestType::ConfigRewrite => 203,
            RequestType::ConfigSet => 204,
            RequestType::DBSize => 205,
            RequestType::FailOver => 206,
            RequestType::FlushAll => 207,
            RequestType::FlushDB => 208,
            RequestType::Info => 209,
            RequestType::LastSave => 210,
            RequestType::LatencyDoctor => 211,
            RequestType::LatencyGraph => 212,
            RequestType::LatencyHistogram => 213,
            RequestType::LatencyHistory => 214,
            RequestType::LatencyLatest => 215,
            RequestType::LatencyReset => 216,
            RequestType::Lolwut => 217,
            RequestType::MemoryDoctor => 218,
            RequestType::MemoryMallocStats => 219,
            RequestType::MemoryPurge => 220,
            RequestType::MemoryStats => 221,
            RequestType::MemoryUsage => 222,
            RequestType::ModuleList => 223,
            RequestType::ModuleLoad => 224,
            RequestType::ModuleLoadEx => 225,
            RequestType::ModuleUnload => 226,
            RequestType::Monitor => 227,
            RequestType::PSync => 228,
            RequestType::ReplConf => 229,
            RequestType::ReplicaOf => 230,
            RequestType::RestoreAsking => 231,
            RequestType::Role => 232,
            RequestType::Save => 233,
            RequestType::ShutDown => 234,
            RequestType::SlaveOf => 235,
            RequestType::SlowLogGet => 236,
            RequestType::SlowLogLen => 237,
            RequestType::SlowLogReset => 238,
            RequestType::SwapDb => 239,
            RequestType::Sync => 240,
            RequestType::Time => 241,
            RequestType::SAdd => 242,
            RequestType::SCard => 243,
            RequestType::SDiff => 244,
            RequestType::SDiffStore => 245,
            RequestType::SInter => 246,
            RequestType::SInterCard => 247,
            RequestType::SInterStore => 248,
            RequestType::SIsMember => 249,
            RequestType::SMembers => 250,
            RequestType::SMIsMember => 251,
            RequestType::SMove => 252,
            RequestType::SPop => 253,
            RequestType::SRandMember => 254,
            RequestType::SRem => 255,
            RequestType::SScan => 256,
            RequestType::SUnion => 257,
            RequestType::SUnionStore => 258,
            RequestType::BZMPop => 259,
            RequestType::BZPopMax => 260,
            RequestType::BZPopMin => 261,
            RequestType::ZAdd => 262,
            RequestType::ZCard => 263,
            RequestType::ZCount => 264,
            RequestType::ZDiff => 265,
            RequestType::ZDiffStore => 266,
            RequestType::ZIncrBy => 267,
            RequestType::ZInter => 268,
            RequestType::ZInterCard => 269,
            RequestType::ZInterStore => 270,
            RequestType::ZLexCount => 271,
            RequestType::ZMPop => 272,
            RequestType::ZMScore => 273,
            RequestType::ZPopMax => 274,
            RequestType::ZPopMin => 275,
            RequestType::ZRandMember => 276,
            RequestType::ZRange => 277,
            RequestType::ZRangeByLex => 278,
            RequestType::ZRangeByScore => 279,
            RequestType::ZRangeStore => 280,
            RequestType::ZRank => 281,
            RequestType::ZRem => 282,
            RequestType::ZRemRangeByLex => 283,
            RequestType::ZRemRangeByRank => 284,
            RequestType::ZRemRangeByScore => 285,
            RequestType::ZRevRange => 286,
            RequestType::ZRevRangeByLex => 287,
            RequestType::ZRevRangeByScore => 288,
            RequestType::ZRevRank => 289,
            RequestType::ZScan => 290,
            RequestType::ZScore => 291,
            RequestType::ZUnion => 292,
            RequestType::ZUnionStore => 293,
            RequestType::XAck => 294,
            RequestType::XAdd => 295,
            RequestType::XAutoClaim => 296,
            RequestType::XClaim => 297,
            RequestType::XDel => 298,
            RequestType::XGroupCreate => 299,
            RequestType::XGroupCreateConsumer => 300,
            RequestType::XGroupDelConsumer => 301,
            RequestType::XGroupDestroy => 302,
            RequestType::XGroupSetId => 303,
            RequestType::XInfoConsumers => 304,
            RequestType::XInfoGroups => 305,
            RequestType::XInfoStream => 306,
            RequestType::XLen => 307,
            RequestType::XPending => 308,
            RequestType::XRange => 309,
            RequestType::XRead => 310,
            RequestType::XReadGroup => 311,
            RequestType::XRevRange => 312,
            RequestType::XSetId => 313,
            RequestType::XTrim => 314,
            RequestType::Append => 315,
            RequestType::Decr => 316,
            RequestType::DecrBy => 317,
            RequestType::Get => 318,
            RequestType::GetDel => 319,
            RequestType::GetEx => 320,
            RequestType::GetRange => 321,
            RequestType::GetSet => 322,
            RequestType::Incr => 323,
            RequestType::IncrBy => 324,
            RequestType::IncrByFloat => 325,
            RequestType::LCS => 326,
            RequestType::MGet => 327,
            RequestType::MSet => 328,
            RequestType::MSetNX => 329,
            RequestType::PSetEx => 330,
            RequestType::Set => 331,
            RequestType::SetEx => 332,
            RequestType::SetNX => 333,
            RequestType::SetRange => 334,
            RequestType::Strlen => 335,
            RequestType::Substr => 336,
            RequestType::Discard => 337,
            RequestType::Exec => 338,
            RequestType::Multi => 339,
            RequestType::UnWatch => 340,
            RequestType::Watch => 341,
            RequestType::JsonArrAppend => 342,
            RequestType::JsonArrIndex => 343,
            RequestType::JsonArrInsert => 344,
            RequestType::JsonArrLen => 345,
            RequestType::JsonArrPop => 346,
            RequestType::JsonArrTrim => 347,
            RequestType::JsonClear => 348,
            RequestType::JsonDebug => 349,
            RequestType::JsonDel => 350,
            RequestType::JsonForget => 351,
            RequestType::JsonGet => 352,
            RequestType::JsonMGet => 353,
            RequestType::JsonNumIncrBy => 354,
            RequestType::JsonNumMultBy => 355,
            RequestType::JsonObjKeys => 356,
            RequestType::JsonObjLen => 357,
            RequestType::JsonResp => 358,
            RequestType::JsonSet => 359,
            RequestType::JsonStrAppend => 360,
            RequestType::JsonStrLen => 361,
            RequestType::JsonToggle => 362,
            RequestType::JsonType => 363,
            RequestType::FtList => 364,
            RequestType::FtAggregate => 365,
            RequestType::FtAliasAdd => 366,
            RequestType::FtAliasDel => 367,
            RequestType::FtAliasList => 368,
            RequestType::FtAliasUpdate => 369,
            RequestType::FtCreate => 370,
            RequestType::FtDropIndex => 371,
            RequestType::FtExplain => 372,
            RequestType::FtExplainCli => 373,
            RequestType::FtInfo => 374,
            RequestType::FtProfile => 375,
            RequestType::FtSearch => 376,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RequestType {
    fn default() -> Self {
        RequestType::InvalidRequest
    }
}

impl RequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RequestType>("RequestType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1eprotobuf/command_request.proto\x12\x0fcommand_request\"_\n\x0bSlot\
    IdRoute\x127\n\tslot_type\x18\x01\x20\x01(\x0e2\x1a.command_request.Slot\
    TypesR\x08slotType\x12\x17\n\x07slot_id\x18\x02\x20\x01(\x05R\x06slotId\
    \"b\n\x0cSlotKeyRoute\x127\n\tslot_type\x18\x01\x20\x01(\x0e2\x1a.comman\
    d_request.SlotTypesR\x08slotType\x12\x19\n\x08slot_key\x18\x02\x20\x01(\
    \tR\x07slotKey\"8\n\x0eByAddressRoute\x12\x12\n\x04host\x18\x01\x20\x01(\
    \tR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\"\xaf\x02\n\
    \x06Routes\x12D\n\rsimple_routes\x18\x01\x20\x01(\x0e2\x1d.command_reque\
    st.SimpleRoutesH\0R\x0csimpleRoutes\x12E\n\x0eslot_key_route\x18\x02\x20\
    \x01(\x0b2\x1d.command_request.SlotKeyRouteH\0R\x0cslotKeyRoute\x12B\n\r\
    slot_id_route\x18\x03\x20\x01(\x0b2\x1c.command_request.SlotIdRouteH\0R\
    \x0bslotIdRoute\x12K\n\x10by_address_route\x18\x04\x20\x01(\x0b2\x1f.com\
    mand_request.ByAddressRouteH\0R\x0ebyAddressRouteB\x07\n\x05value\"\xe4\
    \x01\n\x07Command\x12?\n\x0crequest_type\x18\x01\x20\x01(\x0e2\x1c.comma\
    nd_request.RequestTypeR\x0brequestType\x12C\n\nargs_array\x18\x02\x20\
    \x01(\x0b2\".command_request.Command.ArgsArrayH\0R\targsArray\x12*\n\x10\
    args_vec_pointer\x18\x03\x20\x01(\x04H\0R\x0eargsVecPointer\x1a\x1f\n\tA\
    rgsArray\x12\x12\n\x04args\x18\x01\x20\x03(\x0cR\x04argsB\x06\n\x04args\
    \"\xa0\x01\n\x18ScriptInvocationPointers\x12\x12\n\x04hash\x18\x01\x20\
    \x01(\tR\x04hash\x12&\n\x0ckeys_pointer\x18\x02\x20\x01(\x04H\0R\x0bkeys\
    Pointer\x88\x01\x01\x12&\n\x0cargs_pointer\x18\x03\x20\x01(\x04H\x01R\
    \x0bargsPointer\x88\x01\x01B\x0f\n\r_keys_pointerB\x0f\n\r_args_pointer\
    \"N\n\x10ScriptInvocation\x12\x12\n\x04hash\x18\x01\x20\x01(\tR\x04hash\
    \x12\x12\n\x04keys\x18\x02\x20\x03(\x0cR\x04keys\x12\x12\n\x04args\x18\
    \x03\x20\x03(\x0cR\x04args\"C\n\x0bTransaction\x124\n\x08commands\x18\
    \x01\x20\x03(\x0b2\x18.command_request.CommandR\x08commands\"\xbc\x01\n\
    \x0bClusterScan\x12\x16\n\x06cursor\x18\x01\x20\x01(\tR\x06cursor\x12(\n\
    \rmatch_pattern\x18\x02\x20\x01(\x0cH\0R\x0cmatchPattern\x88\x01\x01\x12\
    \x19\n\x05count\x18\x03\x20\x01(\x03H\x01R\x05count\x88\x01\x01\x12$\n\
    \x0bobject_type\x18\x04\x20\x01(\tH\x02R\nobjectType\x88\x01\x01B\x10\n\
    \x0e_match_patternB\x08\n\x06_countB\x0e\n\x0c_object_type\"o\n\x18Updat\
    eConnectionPassword\x12\x1f\n\x08password\x18\x01\x20\x01(\tH\0R\x08pass\
    word\x88\x01\x01\x12%\n\x0eimmediate_auth\x18\x02\x20\x01(\x08R\rimmedia\
    teAuthB\x0b\n\t_password\"\xdd\x04\n\x0eCommandRequest\x12!\n\x0ccallbac\
    k_idx\x18\x01\x20\x01(\rR\x0bcallbackIdx\x12A\n\x0esingle_command\x18\
    \x02\x20\x01(\x0b2\x18.command_request.CommandH\0R\rsingleCommand\x12@\n\
    \x0btransaction\x18\x03\x20\x01(\x0b2\x1c.command_request.TransactionH\0\
    R\x0btransaction\x12P\n\x11script_invocation\x18\x04\x20\x01(\x0b2!.comm\
    and_request.ScriptInvocationH\0R\x10scriptInvocation\x12i\n\x1ascript_in\
    vocation_pointers\x18\x05\x20\x01(\x0b2).command_request.ScriptInvocatio\
    nPointersH\0R\x18scriptInvocationPointers\x12A\n\x0ccluster_scan\x18\x06\
    \x20\x01(\x0b2\x1c.command_request.ClusterScanH\0R\x0bclusterScan\x12i\n\
    \x1aupdate_connection_password\x18\x07\x20\x01(\x0b2).command_request.Up\
    dateConnectionPasswordH\0R\x18updateConnectionPassword\x12-\n\x05route\
    \x18\x08\x20\x01(\x0b2\x17.command_request.RoutesR\x05routeB\t\n\x07comm\
    and*:\n\x0cSimpleRoutes\x12\x0c\n\x08AllNodes\x10\0\x12\x10\n\x0cAllPrim\
    aries\x10\x01\x12\n\n\x06Random\x10\x02*%\n\tSlotTypes\x12\x0b\n\x07Prim\
    ary\x10\0\x12\x0b\n\x07Replica\x10\x01*\xc7/\n\x0bRequestType\x12\x12\n\
    \x0eInvalidRequest\x10\0\x12\x11\n\rCustomCommand\x10\x01\x12\x0c\n\x08B\
    itCount\x10e\x12\x0c\n\x08BitField\x10f\x12\x14\n\x10BitFieldReadOnly\
    \x10g\x12\t\n\x05BitOp\x10h\x12\n\n\x06BitPos\x10i\x12\n\n\x06GetBit\x10\
    j\x12\n\n\x06SetBit\x10k\x12\x0b\n\x06Asking\x10\xc9\x01\x12\x14\n\x0fCl\
    usterAddSlots\x10\xca\x01\x12\x19\n\x14ClusterAddSlotsRange\x10\xcb\x01\
    \x12\x15\n\x10ClusterBumpEpoch\x10\xcc\x01\x12\x1f\n\x1aClusterCountFail\
    ureReports\x10\xcd\x01\x12\x1b\n\x16ClusterCountKeysInSlot\x10\xce\x01\
    \x12\x14\n\x0fClusterDelSlots\x10\xcf\x01\x12\x19\n\x14ClusterDelSlotsRa\
    nge\x10\xd0\x01\x12\x14\n\x0fClusterFailover\x10\xd1\x01\x12\x16\n\x11Cl\
    usterFlushSlots\x10\xd2\x01\x12\x12\n\rClusterForget\x10\xd3\x01\x12\x19\
    \n\x14ClusterGetKeysInSlot\x10\xd4\x01\x12\x10\n\x0bClusterInfo\x10\xd5\
    \x01\x12\x13\n\x0eClusterKeySlot\x10\xd6\x01\x12\x11\n\x0cClusterLinks\
    \x10\xd7\x01\x12\x10\n\x0bClusterMeet\x10\xd8\x01\x12\x10\n\x0bClusterMy\
    Id\x10\xd9\x01\x12\x15\n\x10ClusterMyShardId\x10\xda\x01\x12\x11\n\x0cCl\
    usterNodes\x10\xdb\x01\x12\x14\n\x0fClusterReplicas\x10\xdc\x01\x12\x15\
    \n\x10ClusterReplicate\x10\xdd\x01\x12\x11\n\x0cClusterReset\x10\xde\x01\
    \x12\x16\n\x11ClusterSaveConfig\x10\xdf\x01\x12\x1a\n\x15ClusterSetConfi\
    gEpoch\x10\xe0\x01\x12\x13\n\x0eClusterSetslot\x10\xe1\x01\x12\x12\n\rCl\
    usterShards\x10\xe2\x01\x12\x12\n\rClusterSlaves\x10\xe3\x01\x12\x11\n\
    \x0cClusterSlots\x10\xe4\x01\x12\r\n\x08ReadOnly\x10\xe5\x01\x12\x0e\n\t\
    ReadWrite\x10\xe6\x01\x12\t\n\x04Auth\x10\xad\x02\x12\x12\n\rClientCachi\
    ng\x10\xae\x02\x12\x12\n\rClientGetName\x10\xaf\x02\x12\x13\n\x0eClientG\
    etRedir\x10\xb0\x02\x12\r\n\x08ClientId\x10\xb1\x02\x12\x0f\n\nClientInf\
    o\x10\xb2\x02\x12\x15\n\x10ClientKillSimple\x10\xb3\x02\x12\x0f\n\nClien\
    tKill\x10\xb4\x02\x12\x0f\n\nClientList\x10\xb5\x02\x12\x12\n\rClientNoE\
    vict\x10\xb6\x02\x12\x12\n\rClientNoTouch\x10\xb7\x02\x12\x10\n\x0bClien\
    tPause\x10\xb8\x02\x12\x10\n\x0bClientReply\x10\xb9\x02\x12\x12\n\rClien\
    tSetInfo\x10\xba\x02\x12\x12\n\rClientSetName\x10\xbb\x02\x12\x13\n\x0eC\
    lientTracking\x10\xbc\x02\x12\x17\n\x12ClientTrackingInfo\x10\xbd\x02\
    \x12\x12\n\rClientUnblock\x10\xbe\x02\x12\x12\n\rClientUnpause\x10\xbf\
    \x02\x12\t\n\x04Echo\x10\xc0\x02\x12\n\n\x05Hello\x10\xc1\x02\x12\t\n\
    \x04Ping\x10\xc2\x02\x12\t\n\x04Quit\x10\xc3\x02\x12\n\n\x05Reset\x10\
    \xc4\x02\x12\x0b\n\x06Select\x10\xc5\x02\x12\t\n\x04Copy\x10\x91\x03\x12\
    \x08\n\x03Del\x10\x92\x03\x12\t\n\x04Dump\x10\x93\x03\x12\x0b\n\x06Exist\
    s\x10\x94\x03\x12\x0b\n\x06Expire\x10\x95\x03\x12\r\n\x08ExpireAt\x10\
    \x96\x03\x12\x0f\n\nExpireTime\x10\x97\x03\x12\t\n\x04Keys\x10\x98\x03\
    \x12\x0c\n\x07Migrate\x10\x99\x03\x12\t\n\x04Move\x10\x9a\x03\x12\x13\n\
    \x0eObjectEncoding\x10\x9b\x03\x12\x0f\n\nObjectFreq\x10\x9c\x03\x12\x13\
    \n\x0eObjectIdleTime\x10\x9d\x03\x12\x13\n\x0eObjectRefCount\x10\x9e\x03\
    \x12\x0c\n\x07Persist\x10\x9f\x03\x12\x0c\n\x07PExpire\x10\xa0\x03\x12\
    \x0e\n\tPExpireAt\x10\xa1\x03\x12\x10\n\x0bPExpireTime\x10\xa2\x03\x12\t\
    \n\x04PTTL\x10\xa3\x03\x12\x0e\n\tRandomKey\x10\xa4\x03\x12\x0b\n\x06Ren\
    ame\x10\xa5\x03\x12\r\n\x08RenameNX\x10\xa6\x03\x12\x0c\n\x07Restore\x10\
    \xa7\x03\x12\t\n\x04Scan\x10\xa8\x03\x12\t\n\x04Sort\x10\xa9\x03\x12\x11\
    \n\x0cSortReadOnly\x10\xaa\x03\x12\n\n\x05Touch\x10\xab\x03\x12\x08\n\
    \x03TTL\x10\xac\x03\x12\t\n\x04Type\x10\xad\x03\x12\x0b\n\x06Unlink\x10\
    \xae\x03\x12\t\n\x04Wait\x10\xaf\x03\x12\x0c\n\x07WaitAof\x10\xb0\x03\
    \x12\x0b\n\x06GeoAdd\x10\xf5\x03\x12\x0c\n\x07GeoDist\x10\xf6\x03\x12\
    \x0c\n\x07GeoHash\x10\xf7\x03\x12\x0b\n\x06GeoPos\x10\xf8\x03\x12\x0e\n\
    \tGeoRadius\x10\xf9\x03\x12\x16\n\x11GeoRadiusReadOnly\x10\xfa\x03\x12\
    \x16\n\x11GeoRadiusByMember\x10\xfb\x03\x12\x1e\n\x19GeoRadiusByMemberRe\
    adOnly\x10\xfc\x03\x12\x0e\n\tGeoSearch\x10\xfd\x03\x12\x13\n\x0eGeoSear\
    chStore\x10\xfe\x03\x12\t\n\x04HDel\x10\xd9\x04\x12\x0c\n\x07HExists\x10\
    \xda\x04\x12\t\n\x04HGet\x10\xdb\x04\x12\x0c\n\x07HGetAll\x10\xdc\x04\
    \x12\x0c\n\x07HIncrBy\x10\xdd\x04\x12\x11\n\x0cHIncrByFloat\x10\xde\x04\
    \x12\n\n\x05HKeys\x10\xdf\x04\x12\t\n\x04HLen\x10\xe0\x04\x12\n\n\x05HMG\
    et\x10\xe1\x04\x12\n\n\x05HMSet\x10\xe2\x04\x12\x0f\n\nHRandField\x10\
    \xe3\x04\x12\n\n\x05HScan\x10\xe4\x04\x12\t\n\x04HSet\x10\xe5\x04\x12\
    \x0b\n\x06HSetNX\x10\xe6\x04\x12\x0c\n\x07HStrlen\x10\xe7\x04\x12\n\n\
    \x05HVals\x10\xe8\x04\x12\n\n\x05PfAdd\x10\xbd\x05\x12\x0c\n\x07PfCount\
    \x10\xbe\x05\x12\x0c\n\x07PfMerge\x10\xbf\x05\x12\x0b\n\x06BLMove\x10\
    \xa1\x06\x12\x0b\n\x06BLMPop\x10\xa2\x06\x12\n\n\x05BLPop\x10\xa3\x06\
    \x12\n\n\x05BRPop\x10\xa4\x06\x12\x0f\n\nBRPopLPush\x10\xa5\x06\x12\x0b\
    \n\x06LIndex\x10\xa6\x06\x12\x0c\n\x07LInsert\x10\xa7\x06\x12\t\n\x04LLe\
    n\x10\xa8\x06\x12\n\n\x05LMove\x10\xa9\x06\x12\n\n\x05LMPop\x10\xaa\x06\
    \x12\t\n\x04LPop\x10\xab\x06\x12\t\n\x04LPos\x10\xac\x06\x12\n\n\x05LPus\
    h\x10\xad\x06\x12\x0b\n\x06LPushX\x10\xae\x06\x12\x0b\n\x06LRange\x10\
    \xaf\x06\x12\t\n\x04LRem\x10\xb0\x06\x12\t\n\x04LSet\x10\xb1\x06\x12\n\n\
    \x05LTrim\x10\xb2\x06\x12\t\n\x04RPop\x10\xb3\x06\x12\x0e\n\tRPopLPush\
    \x10\xb4\x06\x12\n\n\x05RPush\x10\xb5\x06\x12\x0b\n\x06RPushX\x10\xb6\
    \x06\x12\x0f\n\nPSubscribe\x10\x85\x07\x12\x0c\n\x07Publish\x10\x86\x07\
    \x12\x13\n\x0ePubSubChannels\x10\x87\x07\x12\x11\n\x0cPubSubNumPat\x10\
    \x88\x07\x12\x11\n\x0cPubSubNumSub\x10\x89\x07\x12\x18\n\x13PubSubShardC\
    hannels\x10\x8a\x07\x12\x16\n\x11PubSubShardNumSub\x10\x8b\x07\x12\x11\n\
    \x0cPUnsubscribe\x10\x8c\x07\x12\r\n\x08SPublish\x10\x8d\x07\x12\x0f\n\n\
    SSubscribe\x10\x8e\x07\x12\x0e\n\tSubscribe\x10\x8f\x07\x12\x11\n\x0cSUn\
    subscribe\x10\x90\x07\x12\x10\n\x0bUnsubscribe\x10\x91\x07\x12\t\n\x04Ev\
    al\x10\xe9\x07\x12\x11\n\x0cEvalReadOnly\x10\xea\x07\x12\x0c\n\x07EvalSh\
    a\x10\xeb\x07\x12\x14\n\x0fEvalShaReadOnly\x10\xec\x07\x12\n\n\x05FCall\
    \x10\xed\x07\x12\x12\n\rFCallReadOnly\x10\xee\x07\x12\x13\n\x0eFunctionD\
    elete\x10\xef\x07\x12\x11\n\x0cFunctionDump\x10\xf0\x07\x12\x12\n\rFunct\
    ionFlush\x10\xf1\x07\x12\x11\n\x0cFunctionKill\x10\xf2\x07\x12\x11\n\x0c\
    FunctionList\x10\xf3\x07\x12\x11\n\x0cFunctionLoad\x10\xf4\x07\x12\x14\n\
    \x0fFunctionRestore\x10\xf5\x07\x12\x12\n\rFunctionStats\x10\xf6\x07\x12\
    \x10\n\x0bScriptDebug\x10\xf7\x07\x12\x11\n\x0cScriptExists\x10\xf8\x07\
    \x12\x10\n\x0bScriptFlush\x10\xf9\x07\x12\x0f\n\nScriptKill\x10\xfa\x07\
    \x12\x0f\n\nScriptLoad\x10\xfb\x07\x12\x0f\n\nScriptShow\x10\xfc\x07\x12\
    \x0b\n\x06AclCat\x10\xcd\x08\x12\x0f\n\nAclDelUser\x10\xce\x08\x12\x0e\n\
    \tAclDryRun\x10\xcf\x08\x12\x0f\n\nAclGenPass\x10\xd0\x08\x12\x0f\n\nAcl\
    GetUser\x10\xd1\x08\x12\x0c\n\x07AclList\x10\xd2\x08\x12\x0c\n\x07AclLoa\
    d\x10\xd3\x08\x12\x0b\n\x06AclLog\x10\xd4\x08\x12\x0c\n\x07AclSave\x10\
    \xd5\x08\x12\x0f\n\nAclSetSser\x10\xd6\x08\x12\r\n\x08AclUsers\x10\xd7\
    \x08\x12\x0e\n\tAclWhoami\x10\xd8\x08\x12\x11\n\x0cBgRewriteAof\x10\xd9\
    \x08\x12\x0b\n\x06BgSave\x10\xda\x08\x12\r\n\x08Command_\x10\xdb\x08\x12\
    \x11\n\x0cCommandCount\x10\xdc\x08\x12\x10\n\x0bCommandDocs\x10\xdd\x08\
    \x12\x13\n\x0eCommandGetKeys\x10\xde\x08\x12\x1b\n\x16CommandGetKeysAndF\
    lags\x10\xdf\x08\x12\x10\n\x0bCommandInfo\x10\xe0\x08\x12\x10\n\x0bComma\
    ndList\x10\xe1\x08\x12\x0e\n\tConfigGet\x10\xe2\x08\x12\x14\n\x0fConfigR\
    esetStat\x10\xe3\x08\x12\x12\n\rConfigRewrite\x10\xe4\x08\x12\x0e\n\tCon\
    figSet\x10\xe5\x08\x12\x0b\n\x06DBSize\x10\xe6\x08\x12\r\n\x08FailOver\
    \x10\xe7\x08\x12\r\n\x08FlushAll\x10\xe8\x08\x12\x0c\n\x07FlushDB\x10\
    \xe9\x08\x12\t\n\x04Info\x10\xea\x08\x12\r\n\x08LastSave\x10\xeb\x08\x12\
    \x12\n\rLatencyDoctor\x10\xec\x08\x12\x11\n\x0cLatencyGraph\x10\xed\x08\
    \x12\x15\n\x10LatencyHistogram\x10\xee\x08\x12\x13\n\x0eLatencyHistory\
    \x10\xef\x08\x12\x12\n\rLatencyLatest\x10\xf0\x08\x12\x11\n\x0cLatencyRe\
    set\x10\xf1\x08\x12\x0b\n\x06Lolwut\x10\xf2\x08\x12\x11\n\x0cMemoryDocto\
    r\x10\xf3\x08\x12\x16\n\x11MemoryMallocStats\x10\xf4\x08\x12\x10\n\x0bMe\
    moryPurge\x10\xf5\x08\x12\x10\n\x0bMemoryStats\x10\xf6\x08\x12\x10\n\x0b\
    MemoryUsage\x10\xf7\x08\x12\x0f\n\nModuleList\x10\xf8\x08\x12\x0f\n\nMod\
    uleLoad\x10\xf9\x08\x12\x11\n\x0cModuleLoadEx\x10\xfa\x08\x12\x11\n\x0cM\
    oduleUnload\x10\xfb\x08\x12\x0c\n\x07Monitor\x10\xfc\x08\x12\n\n\x05PSyn\
    c\x10\xfd\x08\x12\r\n\x08ReplConf\x10\xfe\x08\x12\x0e\n\tReplicaOf\x10\
    \xff\x08\x12\x12\n\rRestoreAsking\x10\x80\t\x12\t\n\x04Role\x10\x81\t\
    \x12\t\n\x04Save\x10\x82\t\x12\r\n\x08ShutDown\x10\x83\t\x12\x0c\n\x07Sl\
    aveOf\x10\x84\t\x12\x0f\n\nSlowLogGet\x10\x85\t\x12\x0f\n\nSlowLogLen\
    \x10\x86\t\x12\x11\n\x0cSlowLogReset\x10\x87\t\x12\x0b\n\x06SwapDb\x10\
    \x88\t\x12\t\n\x04Sync\x10\x89\t\x12\t\n\x04Time\x10\x8a\t\x12\t\n\x04SA\
    dd\x10\xb1\t\x12\n\n\x05SCard\x10\xb2\t\x12\n\n\x05SDiff\x10\xb3\t\x12\
    \x0f\n\nSDiffStore\x10\xb4\t\x12\x0b\n\x06SInter\x10\xb5\t\x12\x0f\n\nSI\
    nterCard\x10\xb6\t\x12\x10\n\x0bSInterStore\x10\xb7\t\x12\x0e\n\tSIsMemb\
    er\x10\xb8\t\x12\r\n\x08SMembers\x10\xb9\t\x12\x0f\n\nSMIsMember\x10\xba\
    \t\x12\n\n\x05SMove\x10\xbb\t\x12\t\n\x04SPop\x10\xbc\t\x12\x10\n\x0bSRa\
    ndMember\x10\xbd\t\x12\t\n\x04SRem\x10\xbe\t\x12\n\n\x05SScan\x10\xbf\t\
    \x12\x0b\n\x06SUnion\x10\xc0\t\x12\x10\n\x0bSUnionStore\x10\xc1\t\x12\
    \x0b\n\x06BZMPop\x10\x95\n\x12\r\n\x08BZPopMax\x10\x96\n\x12\r\n\x08BZPo\
    pMin\x10\x97\n\x12\t\n\x04ZAdd\x10\x98\n\x12\n\n\x05ZCard\x10\x99\n\x12\
    \x0b\n\x06ZCount\x10\x9a\n\x12\n\n\x05ZDiff\x10\x9b\n\x12\x0f\n\nZDiffSt\
    ore\x10\x9c\n\x12\x0c\n\x07ZIncrBy\x10\x9d\n\x12\x0b\n\x06ZInter\x10\x9e\
    \n\x12\x0f\n\nZInterCard\x10\x9f\n\x12\x10\n\x0bZInterStore\x10\xa0\n\
    \x12\x0e\n\tZLexCount\x10\xa1\n\x12\n\n\x05ZMPop\x10\xa2\n\x12\x0c\n\x07\
    ZMScore\x10\xa3\n\x12\x0c\n\x07ZPopMax\x10\xa4\n\x12\x0c\n\x07ZPopMin\
    \x10\xa5\n\x12\x10\n\x0bZRandMember\x10\xa6\n\x12\x0b\n\x06ZRange\x10\
    \xa7\n\x12\x10\n\x0bZRangeByLex\x10\xa8\n\x12\x12\n\rZRangeByScore\x10\
    \xa9\n\x12\x10\n\x0bZRangeStore\x10\xaa\n\x12\n\n\x05ZRank\x10\xab\n\x12\
    \t\n\x04ZRem\x10\xac\n\x12\x13\n\x0eZRemRangeByLex\x10\xad\n\x12\x14\n\
    \x0fZRemRangeByRank\x10\xae\n\x12\x15\n\x10ZRemRangeByScore\x10\xaf\n\
    \x12\x0e\n\tZRevRange\x10\xb0\n\x12\x13\n\x0eZRevRangeByLex\x10\xb1\n\
    \x12\x15\n\x10ZRevRangeByScore\x10\xb2\n\x12\r\n\x08ZRevRank\x10\xb3\n\
    \x12\n\n\x05ZScan\x10\xb4\n\x12\x0b\n\x06ZScore\x10\xb5\n\x12\x0b\n\x06Z\
    Union\x10\xb6\n\x12\x10\n\x0bZUnionStore\x10\xb7\n\x12\t\n\x04XAck\x10\
    \xf9\n\x12\t\n\x04XAdd\x10\xfa\n\x12\x0f\n\nXAutoClaim\x10\xfb\n\x12\x0b\
    \n\x06XClaim\x10\xfc\n\x12\t\n\x04XDel\x10\xfd\n\x12\x11\n\x0cXGroupCrea\
    te\x10\xfe\n\x12\x19\n\x14XGroupCreateConsumer\x10\xff\n\x12\x16\n\x11XG\
    roupDelConsumer\x10\x80\x0b\x12\x12\n\rXGroupDestroy\x10\x81\x0b\x12\x10\
    \n\x0bXGroupSetId\x10\x82\x0b\x12\x13\n\x0eXInfoConsumers\x10\x83\x0b\
    \x12\x10\n\x0bXInfoGroups\x10\x84\x0b\x12\x10\n\x0bXInfoStream\x10\x85\
    \x0b\x12\t\n\x04XLen\x10\x86\x0b\x12\r\n\x08XPending\x10\x87\x0b\x12\x0b\
    \n\x06XRange\x10\x88\x0b\x12\n\n\x05XRead\x10\x89\x0b\x12\x0f\n\nXReadGr\
    oup\x10\x8a\x0b\x12\x0e\n\tXRevRange\x10\x8b\x0b\x12\x0b\n\x06XSetId\x10\
    \x8c\x0b\x12\n\n\x05XTrim\x10\x8d\x0b\x12\x0b\n\x06Append\x10\xdd\x0b\
    \x12\t\n\x04Decr\x10\xde\x0b\x12\x0b\n\x06DecrBy\x10\xdf\x0b\x12\x08\n\
    \x03Get\x10\xe0\x0b\x12\x0b\n\x06GetDel\x10\xe1\x0b\x12\n\n\x05GetEx\x10\
    \xe2\x0b\x12\r\n\x08GetRange\x10\xe3\x0b\x12\x0b\n\x06GetSet\x10\xe4\x0b\
    \x12\t\n\x04Incr\x10\xe5\x0b\x12\x0b\n\x06IncrBy\x10\xe6\x0b\x12\x10\n\
    \x0bIncrByFloat\x10\xe7\x0b\x12\x08\n\x03LCS\x10\xe8\x0b\x12\t\n\x04MGet\
    \x10\xe9\x0b\x12\t\n\x04MSet\x10\xea\x0b\x12\x0b\n\x06MSetNX\x10\xeb\x0b\
    \x12\x0b\n\x06PSetEx\x10\xec\x0b\x12\x08\n\x03Set\x10\xed\x0b\x12\n\n\
    \x05SetEx\x10\xee\x0b\x12\n\n\x05SetNX\x10\xef\x0b\x12\r\n\x08SetRange\
    \x10\xf0\x0b\x12\x0b\n\x06Strlen\x10\xf1\x0b\x12\x0b\n\x06Substr\x10\xf2\
    \x0b\x12\x0c\n\x07Discard\x10\xc1\x0c\x12\t\n\x04Exec\x10\xc2\x0c\x12\n\
    \n\x05Multi\x10\xc3\x0c\x12\x0c\n\x07UnWatch\x10\xc4\x0c\x12\n\n\x05Watc\
    h\x10\xc5\x0c\x12\x12\n\rJsonArrAppend\x10\xd1\x0f\x12\x11\n\x0cJsonArrI\
    ndex\x10\xd2\x0f\x12\x12\n\rJsonArrInsert\x10\xd3\x0f\x12\x0f\n\nJsonArr\
    Len\x10\xd4\x0f\x12\x0f\n\nJsonArrPop\x10\xd5\x0f\x12\x10\n\x0bJsonArrTr\
    im\x10\xd6\x0f\x12\x0e\n\tJsonClear\x10\xd7\x0f\x12\x0e\n\tJsonDebug\x10\
    \xd8\x0f\x12\x0c\n\x07JsonDel\x10\xd9\x0f\x12\x0f\n\nJsonForget\x10\xda\
    \x0f\x12\x0c\n\x07JsonGet\x10\xdb\x0f\x12\r\n\x08JsonMGet\x10\xdc\x0f\
    \x12\x12\n\rJsonNumIncrBy\x10\xdd\x0f\x12\x12\n\rJsonNumMultBy\x10\xde\
    \x0f\x12\x10\n\x0bJsonObjKeys\x10\xdf\x0f\x12\x0f\n\nJsonObjLen\x10\xe0\
    \x0f\x12\r\n\x08JsonResp\x10\xe1\x0f\x12\x0c\n\x07JsonSet\x10\xe2\x0f\
    \x12\x12\n\rJsonStrAppend\x10\xe3\x0f\x12\x0f\n\nJsonStrLen\x10\xe4\x0f\
    \x12\x0f\n\nJsonToggle\x10\xe5\x0f\x12\r\n\x08JsonType\x10\xe6\x0f\x12\
    \x0b\n\x06FtList\x10\xb5\x10\x12\x10\n\x0bFtAggregate\x10\xb6\x10\x12\
    \x0f\n\nFtAliasAdd\x10\xb7\x10\x12\x0f\n\nFtAliasDel\x10\xb8\x10\x12\x10\
    \n\x0bFtAliasList\x10\xb9\x10\x12\x12\n\rFtAliasUpdate\x10\xba\x10\x12\r\
    \n\x08FtCreate\x10\xbb\x10\x12\x10\n\x0bFtDropIndex\x10\xbc\x10\x12\x0e\
    \n\tFtExplain\x10\xbd\x10\x12\x11\n\x0cFtExplainCli\x10\xbe\x10\x12\x0b\
    \n\x06FtInfo\x10\xbf\x10\x12\x0e\n\tFtProfile\x10\xc0\x10\x12\r\n\x08FtS\
    earch\x10\xc1\x10b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(SlotIdRoute::generated_message_descriptor_data());
            messages.push(SlotKeyRoute::generated_message_descriptor_data());
            messages.push(ByAddressRoute::generated_message_descriptor_data());
            messages.push(Routes::generated_message_descriptor_data());
            messages.push(Command::generated_message_descriptor_data());
            messages.push(ScriptInvocationPointers::generated_message_descriptor_data());
            messages.push(ScriptInvocation::generated_message_descriptor_data());
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(ClusterScan::generated_message_descriptor_data());
            messages.push(UpdateConnectionPassword::generated_message_descriptor_data());
            messages.push(CommandRequest::generated_message_descriptor_data());
            messages.push(command::ArgsArray::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(SimpleRoutes::generated_enum_descriptor_data());
            enums.push(SlotTypes::generated_enum_descriptor_data());
            enums.push(RequestType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
